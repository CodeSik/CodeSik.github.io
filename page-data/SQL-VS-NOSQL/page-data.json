{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/SQL-VS-NOSQL/",
    "result": {"data":{"cur":{"id":"e8468b17-0f1f-58a1-9e97-932dcea7d541","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB67laESv/xAAWEAADAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFX//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8BNX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARAhETGx/9oACAEBAAE/IQaq+Roy3H//2gAMAwEAAgADAAAAEO/v/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QChn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAhMRD/2gAIAQEAAT8QJBMw+PeSPgqp6Z5Fplbv/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg\"\n        srcset=\"/static/051302852db76565424e416e3d55fbc9/4ec73/database_sql_vs_nosql.jpg 180w,\n/static/051302852db76565424e416e3d55fbc9/158ba/database_sql_vs_nosql.jpg 360w,\n/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg 720w,\n/static/051302852db76565424e416e3d55fbc9/acb04/database_sql_vs_nosql.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[Database] SQL과 NoSQL의 비교</p>\n<h2 id=\"sql\" style=\"position:relative;\"><a href=\"#sql\" aria-label=\"sql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h2>\n<p>SQL이란 Structured Query Language 입니다. RDBMS(관계형 데이터베이스 관리 시스템)과 상호 작용을 하기 위한 언어이며, 데이터베이스가 아닙니다. 어쨌든 중요한건 SQL는 관계형 데이터베이스를 다룰 때 사용한다는 것입니다.</p>\n<p><strong>RDBMS에는 두가지의 중요한 특성이 있습니다.</strong></p>\n<ul>\n<li>데이터는 정해진(엄격한) 데이터 스키마 (= structure)를 따라 데이터베이스 테이블에 저장됩니다.</li>\n<li>데이터는 관계를 통해서 연결된 여러개의 테이블에 분산됩니다.</li>\n</ul>\n<h3 id=\"엄격한-스키마\" style=\"position:relative;\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\" aria-label=\"엄격한 스키마 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엄격한 스키마</h3>\n<p>데이터는 Table에 Record로 저장이 되며, 명확하게 정의된 Schema가 존재합니다. Schema는 구조이며, 이 구조에 적합하지 않은 Record는 Table에 추가할 수가 없습니다. 그래서 <code class=\"language-text\">엄격한</code> 이란 표현을 쓰는겁니다.</p>\n<h3 id=\"관계\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EA%B3%84\" aria-label=\"관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계</h3>\n<p>이름에서부터 알 수 있듯이 <code class=\"language-text\">관계형 데이터베이스</code> 입니다. 각 테이블마다 관계를 맺고있다는 뜻입니다. 이게 중요한 이유는 중복을 피할 수 있다는 것입니다. 그 관계는 Foregin Key와 Primary Key로 구현을 합니다. 예를들어서 어떤 유저가 어떤 주문을 했는지를 조회하고자 해봅시다. 만약 테이블마다 관계를 맺을 수 없다면 유저 테이블에 어떤 주문을 했는지를 표시해야 할 것이고, 주문 테이블에 유저의 정보를 모두 넣어줘야겠습니다.</p>\n<p>하지만 명확하게 한개로만 구분되는 Primary Key(id..etc)를 Foregin Key로 가져와 관계를 맺을 수 있다면, 서로 테이블간 레코드가 중복될 필요 없이 데이터를 조회할 수 있습니다. <code class=\"language-text\">Join</code> 연산을 사용해서요.</p>\n<hr>\n<h2 id=\"nosql\" style=\"position:relative;\"><a href=\"#nosql\" aria-label=\"nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h2>\n<p>NoSQL은 이름처럼 SQL과 반대의 방식으로 데이터베이스에 접근하기 때문에 지어졌습니다.</p>\n<p>SQL의 주요한 특성인</p>\n<ul>\n<li>스키마</li>\n<li>관계</li>\n</ul>\n<p>이 두 개가 없습니다.</p>\n<p>이 두 개가 없다는 말은 곧, 스키마(구조)를 따르지 않고 데이터를 <code class=\"language-text\">Collection(RDBMS의 테이블)</code> 에 추가할 수 있습니다.</p>\n<p>관계가 없기 때문에 <code class=\"language-text\">Join</code> 의 개념또한 없습니다. 위에서 설명했던 유저와 주문의 관계를 살펴본다면, 주문이라는 컬렉션의 모든 유저의 정보를 같이 저장하는 겁니다.</p>\n<p>위 방식은 데이터가 중복되기 때문에, 중복되는 데이터를 수정하는 경우 모두 다 업데이트 되도록 하는 것이 중요하다고 할 수 있습니다. 그래서 자주 변경되지 않는 데이터 일 때 큰 장점이 있습니다.</p>\n<hr>\n<h2 id=\"두-데이터베이스의-비교\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"두 데이터베이스의 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 데이터베이스의 비교</h2>\n<h3 id=\"수직적-vs-수평적-확장scailing\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\" aria-label=\"수직적 vs 수평적 확장scailing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수직적 vs 수평적 확장(Scailing)</h3>\n<p>데이터베이스의 확장성이 어느 방향에 있냐에 따라서 두 데이터베이스가 나뉘게 됩니다.</p>\n<ul>\n<li><strong>수직적 확장</strong>은 데이터베이스 서버의 성능을 향상시키는 겁니다. (CPU 등의 하드웨어 교체)</li>\n<li><strong>수평적 확장</strong>은 서버를 분산시키는 것을 의미합니다.</li>\n</ul>\n<p><code class=\"language-text\">RDBMS</code> 에서는 수직적 확장만 가능합니다. 수평적 확장(Sharding)을 할 수는 있지만 구현하는게 굉장히 까다롭습니다. <code class=\"language-text\">NoSQL</code>에서는 이를 기본적으로 지원하므로 서버를 더 많이 추가하여 분산시키는 것이 가능합니다.</p>\n<h2 id=\"각-데이터베이스의-장단점\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"각 데이터베이스의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 데이터베이스의 장단점</h2>\n<p>둘 중 뭐가 낫다는 없습니다. 구현해야할 상황에 따라서 어떠한 데이터를 다루는지, 어플리케이션이 어떠한 특징을 가지고 있는지에 따라서 유연하게 선택해야합니다.</p>\n<h3 id=\"sql의-장단점\" style=\"position:relative;\"><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"sql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마를 명확히 정의하여 무결성 보장</li>\n<li>Record의 중복이 없음</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li><code class=\"language-text\">NoSQL</code>에 비해서 상대적으로 덜 유연하기 때문에 나중에 수정이 번거롭다. 불가능할 수도 있다.</li>\n<li>Join문이 많은 복잡한 쿼리가 만들어 질 수 있다.</li>\n<li>수평적 확장이 어렵고 대체로 수직적 확장만 가능하다. 이렇게 되면 어느 시점에서 한계점에 직면할 수 있다.</li>\n</ul>\n<h3 id=\"nosql의-장단점\" style=\"position:relative;\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"nosql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마가 없어 굉장히 유연하다. 언제든지 구조에 신경쓰지 않고 새로운 <code class=\"language-text\">Document</code> 를 추가할 수 있다.</li>\n<li>데이터는 어플리케이션에서 요구하는 형식으로 저장되기 때문에 데이터를 읽어오는 속도가 빨라진다.</li>\n<li>수직적, 수평적 확장이 모두 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>유연함 때문에 오히려 데이터의 구조가 제대로 안정해질 수도 있다.</li>\n<li>중복된 데이터가 변경되면 중복된 데이터가 있는 여러개의 <code class=\"language-text\">Collection</code>에서 변경이 이뤄져야 한다.</li>\n</ul>\n<h2 id=\"각각은-언제-사용하는-것이-좋을까\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"각각은 언제 사용하는 것이 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각각은 언제 사용하는 것이 좋을까?</h2>\n<h3 id=\"sql-1\" style=\"position:relative;\"><a href=\"#sql-1\" aria-label=\"sql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h3>\n<ul>\n<li>데이터가 자주 변경되어야 하는 경우(NoSQL은 컬렉션을 모두 수정해야 하기 때문에)</li>\n<li>구조가 변경될 여지가 없으며 명확한 스키마를 정의하는 것이 사용자와 데이터에게 중요한 경우</li>\n</ul>\n<h3 id=\"nosql-1\" style=\"position:relative;\"><a href=\"#nosql-1\" aria-label=\"nosql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h3>\n<ul>\n<li>정확한 데이터 구조를 몰라 변경, 확장이 될 수 있는 경우</li>\n<li>조회는 많이 하지만 데이터의 변경이 자주 있지 않는 경우</li>\n<li>데이터베이스를 수평적으로 확장해야 하는 경우, 즉 굉장히 많은 양의 데이터를 다뤄야 하는 경우</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#sql\">SQL</a></p>\n<ul>\n<li><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\">엄격한 스키마</a></li>\n<li><a href=\"#%EA%B4%80%EA%B3%84\">관계</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nosql\">NoSQL</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\">두 데이터베이스의 비교</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\">수직적 vs 수평적 확장(Scailing)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">각 데이터베이스의 장단점</a></p>\n<ul>\n<li><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">SQL의 장단점</a></li>\n<li><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">NoSQL의 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">각각은 언제 사용하는 것이 좋을까?</a></p>\n<ul>\n<li><a href=\"#sql-1\">SQL</a></li>\n<li><a href=\"#nosql-1\">NoSQL</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"SQL SQL이란 Structured Query Language 입니다. RDBMS(관계형 데이터베이스 관리 시스템)과 상호 작용을 하기 위한 언어이며, 데이터베이스가 아닙니다. 어쨌든 중요한건 SQL는 관계형 데이터베이스를 다룰 때 사용한다는 것입니다. RDBMS에는 두가지의 중요한 특성이 있습니다. 데이터는 정해진(엄격한) 데이터 스키마 (= structure)를 따라 데이터베이스 테이블에 저장됩니다. 데이터는 관계를 통해서 연결된 여러개의 테이블에 분산됩니다. 엄격한 스키마 데이터는 Table에 Record로 저장이 되며, 명확하게 정의된 Schema가 존재합니다. Schema는 구조이며, 이 구조에 적합하지 않은 Record는 Table에 추가할 수가 없습니다. 그래서  이란 표현을 쓰는겁니다. 관계 이름에서부터 알 수 있듯이  입니다. 각 테이블마다 관계를 맺고있다는 뜻입니다. 이게 중요한 이유는 중복을 피할 수 있다는 것입니다. 그 관계는 Foregin Key와 Prim…","frontmatter":{"date":"April 04, 2021","title":"SQL과 NoSQL의 비교","categories":"Database","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/SQL-VS-NOSQL/"}},"next":{"id":"013b0786-94ad-550c-8f21-030742b9273e","html":"<p class=\"callout\"> 💡[JAVA] JVM의 Garbage Collection </p>\n<h1 id=\"garbage-collection\" style=\"position:relative;\"><a href=\"#garbage-collection\" aria-label=\"garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collection</h1>\n<p>C/C++ 에서는 메모리를 개발자가 명시적으로 해제하지만 JVM 기반 어플리케이션에서는 명시적으로 해제를 하지 않습니다. JVM의 Garbage Collector가 더이상 사용되지 않는 인스턴스를 찾아내서 메모리를 삭제하는 행위를 합니다.</p>\n<hr>\n<h2 id=\"동작-방식\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작 방식</h2>\n<h3 id=\"stop-the-world\" style=\"position:relative;\"><a href=\"#stop-the-world\" aria-label=\"stop the world permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop The World</h3>\n<p>앞서 말씀드렸듯 <code class=\"language-text\">Garbage Collector</code>는 자동으로 JVM이 판단하여 사용되지 않는 인스턴스의 할당을 해제하는 역할을 합니다. 다만 메모리를 해제하기 위해서는 자바 어플리케이션의 GC를 실행하기 위한 쓰레드를 제외하고 모두 멈추게 되고, GC가 완료된 후에야 다른 쓰레드가 작동하게 됩니다. 이러한 상태를 <code class=\"language-text\">Stop The World</code>라고 합니다.</p>\n<h3 id=\"mark-and-sweep\" style=\"position:relative;\"><a href=\"#mark-and-sweep\" aria-label=\"mark and sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark and Sweep</h3>\n<p><code class=\"language-text\">Stop The World</code>  상태에서 GC는 스택의 모든 변수나 Reachable 객체를 스캔한다. 여기서 사용되고 있는 메모리를 찾아내는 과정이 <code class=\"language-text\">Mark</code> , 식별되지 않은 객체를 메모리에서 제거하는 과정이 <code class=\"language-text\">Sweep</code> 이다.</p>\n<h3 id=\"gc-튜닝\" style=\"position:relative;\"><a href=\"#gc-%ED%8A%9C%EB%8B%9D\" aria-label=\"gc 튜닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC 튜닝</h3>\n<p>GC 튜닝이란 이러한 Stop The World 상태의 시간을 최소한으로 하는 작업이라고 보시면 됩니다.</p>\n<h2 id=\"sun-jvm의-young-generation--old-generation\" style=\"position:relative;\"><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\" aria-label=\"sun jvm의 young generation  old generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sun JVM의 Young Generation / Old Generation</h2>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code>: 생명 주기가 짧은 객체를 GC의 대상으로 하는 영역</p>\n<p><code class=\"language-text\">Old Generation(Major GC)</code>: 생명 주기가 긴 객체를 GC의 대상으로 하는 영역</p>\n<p>일반적인 JVM Application은 생명주기가 짧은 객체가 훨씬 많습니다. 그래서 Sun JVM의 <code class=\"language-text\">Generation Heap</code> 은 Young Generation에 속한 객체의 빠른 생성과 제거를 보장하는 성격을 지니고 있습니다.</p>\n<h3 id=\"young-generation-동작-방식\" style=\"position:relative;\"><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"young generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young Generation 동작 방식</h3>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code> 는 3개의 영역으로 나뉘어 집니다.</p>\n<ul>\n<li>Eden 영역</li>\n<li>2개의 Survivor 영역</li>\n</ul>\n<p>객체가 처음 생성되면  <code class=\"language-text\">Eden</code> 영역에 할당이 됩니다. 계속 할당이 되다가  <code class=\"language-text\">Eden</code> 영역이 꽉차게 되면 Minor GC 가 활성화 됩니다. 이 때 Stop The wolrd 상태가 되는거죠. 사용되지 않은 객체의 메모리를 해제하고 남아있는 <code class=\"language-text\">Eden</code> 영역의 객체들을 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다.</p>\n<p><code class=\"language-text\">Survivor</code> 영역마저 꽉차게 된다면 <code class=\"language-text\">Survivor</code> 영역에서 살아남은 객체를 다른 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다. <code class=\"language-text\">Survivor</code> 영역 중 하나는 반드시 빈 상태를 유지해야 합니다.</p>\n<p>이 과정들을 반복하여 계속 살아남은 객체는 <code class=\"language-text\">Old Generation</code> 으로 Promotion(이동) 됩니다.</p>\n<h3 id=\"old-generation-동작-방식\" style=\"position:relative;\"><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"old generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old Generation 동작 방식</h3>\n<p><code class=\"language-text\">Old Generation(Major GC)</code> 에서 <code class=\"language-text\">Major GC</code> 가 활성화 되기 위해선 해당 영역에 객체가 꽉 차야합니다. 다만 Major GC는 굉장히 오래걸리는 작업입니다. Young 영역보다 크기가 클 뿐더러, Young 영역의 객체를 참조하고 있을 수도 있기 때문입니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">동작 방식</a></p>\n<ul>\n<li><a href=\"#stop-the-world\">Stop The World</a></li>\n<li><a href=\"#mark-and-sweep\">Mark and Sweep</a></li>\n<li><a href=\"#gc-%ED%8A%9C%EB%8B%9D\">GC 튜닝</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\">Sun JVM의 Young Generation / Old Generation</a></p>\n<ul>\n<li><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Young Generation 동작 방식</a></li>\n<li><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Old Generation 동작 방식</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2021","title":"JVM의 Garbage Collection","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/java-gc/"}},"prev":{"id":"6bccb300-15bc-558e-8bec-3cff9e5432a3","html":"<p class=\"callout\"> 💡[Security] 비대칭 암호화와 RSA 알고리즘 </p>\n## 비대칭 암호화\n<p>비대칭 암호화는 암호화, 복호화에 사용하는 키가 2개인 암호화 방식을 의미합니다.</p>\n<p>그 키는 Public Key, Private Key로 나뉩니다.</p>\n<p>일반적으로 Public Key는 자물쇠, Private Key는 그 자물쇠에 맞는 열쇠라고 생각하면 편합니다.</p>\n<p>다만 Public Key, Private Key 둘 다 서로 암호화, 복호화에 사용할 순 있습니다. 일반적으로 그렇다는 겁니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 710px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABNElEQVQY012P30rDMBTG81h7D30h9QnEK/HGR5jgvBwyBJmgAVeos1tpteu6LWvaJm36J8mRpjhXfxfJ+c75voSDwKDNuWGVtxfQpxulQi5IobQ+HqHu6rqTD3L75LdS6X/hRDRWyPtZQPoXAFhs2HydtQEjD30AKGq53OV/L5o+OhZFnouiMLJnAgCpFKVJfx+NOOd5nneeaBcH0f7wJ2OsqqrOWTdy7n53ddM0aZpKKdF2u8UYM8YAAHsU+7SWqqxagiCYzWZSSgAgrHxZ7mNeaSWTJHUcx7Zt9DlvcdyvmGYnl8+Ds8f35WYVkbwQlmXdj+7DaEfj5GbsDC4md1OPkMT1Q4zffN9HxCDKErS+HrvnQ5vyUgihlArDcPQwis2qw9fV6dUUe1TLOmM8itZZlv0AKWHCK8sGp2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/95c292059a5f62745cd430735f538270/7131f/1.png\"\n        srcset=\"/static/95c292059a5f62745cd430735f538270/e9ff0/1.png 180w,\n/static/95c292059a5f62745cd430735f538270/f21e7/1.png 360w,\n/static/95c292059a5f62745cd430735f538270/7131f/1.png 710w\"\n        sizes=\"(max-width: 710px) 100vw, 710px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>출처: codedragon.tistory.com</p>\n</blockquote>\n<h3 id=\"방식\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EC%8B%9D\" aria-label=\"방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방식</h3>\n<p>만약에 A 서버와 B 클라이언트가 정보를 교환한다고 해봅시다.</p>\n<p>A는 B에게 공개키를 제공합니다. 그리고 B가 정보를 보낼 때 공개키로 암호화를 해서 보냅니다.</p>\n<p>이렇게 되면 B가 보낸 정보는 A의 개인키로 밖에 열지 못하기 때문에 유출되더라도 위험하지 않으며</p>\n<p>A에게만 비공개적으로 정보를 보낼 수 있는 것입니다.</p>\n<h3 id=\"https\" style=\"position:relative;\"><a href=\"#https\" aria-label=\"https permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS</h3>\n<p>HTTPS 프로토콜 상에서 통신하는 A 서버와 B 클라이언트가 서로 정보를 교환해야 한다고 가정해봅시다.</p>\n<blockquote>\n<p>HTTPS란?<br></p>\n</blockquote>\n<p>SSL 프로토콜위에서 동작하는 HTTP. 서버가 SSL 인증서를 CA 기관에서 발급받아 정보를 안전하게 교환할 수 있도록 보안성을 높인 프로토콜이다.</p>\n<p>먼저 서버는 CA기관으로 부터 SSL 인증서를 발급받습니다.</p>\n<p>CA에게 공개키를 제공하고, CA는 A의 공개키를 인증기관의 개인키로 암호화합니다.</p>\n<p>그리고 CA에서 발행한 공개키를 통해 이 것을 복호화 하면 인증서에 대한 해쉬값을 얻을 수 있습니다.</p>\n<p>인증서에 등록된 해쉬값과 CA에서 발행한 공개키로 서명값을 복호화해서 나온 것이 서로 동일하면 인증서의 내용과 공개키가 위,변조 되지 않았음을 보증할 수 있습니다.</p>\n<p>클라이언트의 브라우저로 서버에 접속하게 되면, 서버에서 인증서를 사용자에게 제공합니다.</p>\n<p>브라우저가 인증서를 발급한 기관이 브라우저에 등록된 인증기관 리스트에 있는지 확인하고, 인증기관의 공개키를 통해 제공받은 인증서를 복호화합니다. 복호화가 성공하게 되면 인증이 완료되는 것이죠.</p>\n<h3 id=\"블록체인\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\" aria-label=\"블록체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블록체인</h3>\n<p>블록체인에서 자신의 Transaction에 Sign을 할 때도 같은 방식이 사용됩니다.</p>\n<p>트랜잭션을 발생시킨 공개키가 자신의 트랜잭션이다 라는 것을 자신의 개인키로 서명해야만 트랜잭션이 전송되어 블록체인 네트워크에 기록되는 것입니다.</p>\n<p>블록체인에서의 협의 방식은 HTTPS 처럼 인증 가능한 기관이 있는 것이 아닌 <code class=\"language-text\">Proof of Work(POW)</code> 매커니즘을 통해 이뤄집니다.</p>\n<p>간단히 설명하자면 그렇게 서명하여 보낸 트랜잭션이 Valid한지 블록체인 네트워크에 등록된 노드들이 검사를 하는 매커니즘입니다.</p>\n<h3 id=\"rsa-알고리즘\" style=\"position:relative;\"><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"rsa 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RSA 알고리즘</h3>\n<p>비대칭 암호화를 구현하기 위한 대표적인 알고리즘은 RSA알고리즘 입니다. 공개키와 개인키를 생성하기 위한 알고리즘 입니다.</p>\n<p>공개키는 n,e / 개인키는 n,d 라는 각각 두 정수로 이뤄져 있습니다.</p>\n<p>구하는 알고리즘은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>p ≠ q인 두 소수 p와 q를 고릅니다. (EX: p = 17, q = 11)</p>\n</li>\n<li>\n<p>N=pq인 N을 만듭니다. (N = 187)</p>\n</li>\n<li>\n<p>Φ(N)=(p-1)(q-1)을 계산합니다. (16*10 = 160)</p>\n</li>\n<li>\n<p>공개키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 서로소인 수 e를 선택합니다. (e=7)</p>\n</li>\n<li>\n<p>개인키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 d*e mod 160 = 1인 수 를 구합니다. e가 7이었으므로</p>\n<p>7d mod 160 =1을 만족하는 d는 (160+1)/7 이므로, 23입니다.</p>\n</li>\n</ul>\n<p>따라서 결과적으로 공개키는 (187,7) / 개인키는 (187,23)이 됩니다.</p>\n<h3 id=\"암호화-공개키의-n과-e\" style=\"position:relative;\"><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\" aria-label=\"암호화 공개키의 n과 e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>암호화 (공개키의 n과 e)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C = M^e mod n</code></pre></div>\n<h3 id=\"복호화-개인키의-n과-d\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\" aria-label=\"복호화 개인키의 n과 d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복호화 (개인키의 n과 d)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">M = C^d mod n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%B0%A9%EC%8B%9D\">방식</a></li>\n<li><a href=\"#https\">HTTPS</a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\">블록체인</a></li>\n<li><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">RSA 알고리즘</a></li>\n<li><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\">암호화 (공개키의 n과 e)</a></li>\n<li><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\">복호화 (개인키의 n과 d)</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 05, 2021","title":"비대칭 암호화와 RSA 알고리즘","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/Asymmetric-Key/"}},"site":{"siteMetadata":{"siteUrl":"https://codesik.github.io","comments":{"utterances":{"repo":"CodeSik/CodeSik.github.io"}}}}},"pageContext":{"slug":"/SQL-VS-NOSQL/","nextSlug":"/java-gc/","prevSlug":"/Asymmetric-Key/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}