{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/algorithm-1/",
    "result": {"data":{"cur":{"id":"6d03880b-159c-54a4-934b-ccb110137c58","html":"<p class=\"callout\"> 💡[프로그래머스] Level 1 완주하지 못한 선수 | Python</p>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/42576\">문제 링크 및 출처</a></p>\n<p><img src=\"https://i.imgur.com/AJpyecC.png\" alt=\"스크린샷 2021-04-09 오후 8.32.06\"></p>\n<h2 id=\"풀이과정\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\" aria-label=\"풀이과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이과정</h2>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span> completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    <span class=\"token keyword\">for</span> com <span class=\"token keyword\">in</span> completion<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> com <span class=\"token keyword\">in</span> participant<span class=\"token punctuation\">:</span>\n            participant<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># print(participant)</span>\n    <span class=\"token keyword\">return</span> participant<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>처음에는 이렇게 풀었습니다. 완주한 사람의 목록에 있는 사람을 참가자에서 하나씩 빼는겁니다.</p>\n<p>정확도는 모두 맞는데 해시를 쓰지 않으면 조회시간이 오래걸려 효율성 테스트에서 모두 문제가 생깁니다. 따라서 해시기반 자료형을 사용해야 하는데, Python 에서는 <code class=\"language-text\">Dictionary</code>를 사용하면 됩니다.</p>\n<p>저는 근데 위 아이디어를 좀 더 살렸는데요, 파이썬 내장함수중에 <code class=\"language-text\">zip</code>이라는 함수가 있습니다.</p>\n<p>두 리스트를 같은 인덱스 끼리 Tuple로 묶어준다고 생각하시면 됩니다.</p>\n<p>그럼 sort를 한 뒤에 같은 인덱스 묶인 Tuple간 원소를 비교했을 때 다르다면 그게 답이 될겁니다.</p>\n<p>만약 if문에 안걸리면 마지막 원소가 답이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#11:30</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span> completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    participant<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    completion<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> a<span class=\"token punctuation\">,</span>b <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span>completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token operator\">!=</span>b<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> a\n\n    <span class=\"token keyword\">return</span> participant<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\">풀이과정</a></li>\n</ul>\n</div>","excerpt":"문제 링크 및 출처 스크린샷 2021-04-09 오후 8.32.06 풀이과정 처음에는 이렇게 풀었습니다. 완주한 사람의 목록에 있는 사람을 참가자에서 하나씩 빼는겁니다. 정확도는 모두 맞는데 해시를 쓰지 않으면 조회시간이 오래걸려 효율성 테스트에서 모두 문제가 생깁니다. 따라서 해시기반 자료형을 사용해야 하는데, Python 에서는 를 사용하면 됩니다. 저는 근데 위 아이디어를 좀 더 살렸는데요, 파이썬 내장함수중에 이라는 함수가 있습니다. 두 리스트를 같은 인덱스 끼리 Tuple로 묶어준다고 생각하시면 됩니다. 그럼 sort를 한 뒤에 같은 인덱스 묶인 Tuple간 원소를 비교했을 때 다르다면 그게 답이 될겁니다. 만약 if문에 안걸리면 마지막 원소가 답이 됩니다. 풀이과정","frontmatter":{"date":"April 09, 2021","title":"프로그래머스 - Level 1 완주하지 못한 선수 | Python","categories":"Algorithm","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/algorithm-1/"}},"next":{"id":"6bccb300-15bc-558e-8bec-3cff9e5432a3","html":"<p class=\"callout\"> 💡[Security] 비대칭 암호화와 RSA 알고리즘 </p>\n## 비대칭 암호화\n<p>비대칭 암호화는 암호화, 복호화에 사용하는 키가 2개인 암호화 방식을 의미합니다.</p>\n<p>그 키는 Public Key, Private Key로 나뉩니다.</p>\n<p>일반적으로 Public Key는 자물쇠, Private Key는 그 자물쇠에 맞는 열쇠라고 생각하면 편합니다.</p>\n<p>다만 Public Key, Private Key 둘 다 서로 암호화, 복호화에 사용할 순 있습니다. 일반적으로 그렇다는 겁니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 710px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABNElEQVQY012P30rDMBTG81h7D30h9QnEK/HGR5jgvBwyBJmgAVeos1tpteu6LWvaJm36J8mRpjhXfxfJ+c75voSDwKDNuWGVtxfQpxulQi5IobQ+HqHu6rqTD3L75LdS6X/hRDRWyPtZQPoXAFhs2HydtQEjD30AKGq53OV/L5o+OhZFnouiMLJnAgCpFKVJfx+NOOd5nneeaBcH0f7wJ2OsqqrOWTdy7n53ddM0aZpKKdF2u8UYM8YAAHsU+7SWqqxagiCYzWZSSgAgrHxZ7mNeaSWTJHUcx7Zt9DlvcdyvmGYnl8+Ds8f35WYVkbwQlmXdj+7DaEfj5GbsDC4md1OPkMT1Q4zffN9HxCDKErS+HrvnQ5vyUgihlArDcPQwis2qw9fV6dUUe1TLOmM8itZZlv0AKWHCK8sGp2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/95c292059a5f62745cd430735f538270/7131f/1.png\"\n        srcset=\"/static/95c292059a5f62745cd430735f538270/e9ff0/1.png 180w,\n/static/95c292059a5f62745cd430735f538270/f21e7/1.png 360w,\n/static/95c292059a5f62745cd430735f538270/7131f/1.png 710w\"\n        sizes=\"(max-width: 710px) 100vw, 710px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>출처: codedragon.tistory.com</p>\n</blockquote>\n<h3 id=\"방식\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EC%8B%9D\" aria-label=\"방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방식</h3>\n<p>만약에 A 서버와 B 클라이언트가 정보를 교환한다고 해봅시다.</p>\n<p>A는 B에게 공개키를 제공합니다. 그리고 B가 정보를 보낼 때 공개키로 암호화를 해서 보냅니다.</p>\n<p>이렇게 되면 B가 보낸 정보는 A의 개인키로 밖에 열지 못하기 때문에 유출되더라도 위험하지 않으며</p>\n<p>A에게만 비공개적으로 정보를 보낼 수 있는 것입니다.</p>\n<h3 id=\"https\" style=\"position:relative;\"><a href=\"#https\" aria-label=\"https permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS</h3>\n<p>HTTPS 프로토콜 상에서 통신하는 A 서버와 B 클라이언트가 서로 정보를 교환해야 한다고 가정해봅시다.</p>\n<blockquote>\n<p>HTTPS란?<br></p>\n</blockquote>\n<p>SSL 프로토콜위에서 동작하는 HTTP. 서버가 SSL 인증서를 CA 기관에서 발급받아 정보를 안전하게 교환할 수 있도록 보안성을 높인 프로토콜이다.</p>\n<p>먼저 서버는 CA기관으로 부터 SSL 인증서를 발급받습니다.</p>\n<p>CA에게 공개키를 제공하고, CA는 A의 공개키를 인증기관의 개인키로 암호화합니다.</p>\n<p>그리고 CA에서 발행한 공개키를 통해 이 것을 복호화 하면 인증서에 대한 해쉬값을 얻을 수 있습니다.</p>\n<p>인증서에 등록된 해쉬값과 CA에서 발행한 공개키로 서명값을 복호화해서 나온 것이 서로 동일하면 인증서의 내용과 공개키가 위,변조 되지 않았음을 보증할 수 있습니다.</p>\n<p>클라이언트의 브라우저로 서버에 접속하게 되면, 서버에서 인증서를 사용자에게 제공합니다.</p>\n<p>브라우저가 인증서를 발급한 기관이 브라우저에 등록된 인증기관 리스트에 있는지 확인하고, 인증기관의 공개키를 통해 제공받은 인증서를 복호화합니다. 복호화가 성공하게 되면 인증이 완료되는 것이죠.</p>\n<h3 id=\"블록체인\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\" aria-label=\"블록체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블록체인</h3>\n<p>블록체인에서 자신의 Transaction에 Sign을 할 때도 같은 방식이 사용됩니다.</p>\n<p>트랜잭션을 발생시킨 공개키가 자신의 트랜잭션이다 라는 것을 자신의 개인키로 서명해야만 트랜잭션이 전송되어 블록체인 네트워크에 기록되는 것입니다.</p>\n<p>블록체인에서의 협의 방식은 HTTPS 처럼 인증 가능한 기관이 있는 것이 아닌 <code class=\"language-text\">Proof of Work(POW)</code> 매커니즘을 통해 이뤄집니다.</p>\n<p>간단히 설명하자면 그렇게 서명하여 보낸 트랜잭션이 Valid한지 블록체인 네트워크에 등록된 노드들이 검사를 하는 매커니즘입니다.</p>\n<h3 id=\"rsa-알고리즘\" style=\"position:relative;\"><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"rsa 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RSA 알고리즘</h3>\n<p>비대칭 암호화를 구현하기 위한 대표적인 알고리즘은 RSA알고리즘 입니다. 공개키와 개인키를 생성하기 위한 알고리즘 입니다.</p>\n<p>공개키는 n,e / 개인키는 n,d 라는 각각 두 정수로 이뤄져 있습니다.</p>\n<p>구하는 알고리즘은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>p ≠ q인 두 소수 p와 q를 고릅니다. (EX: p = 17, q = 11)</p>\n</li>\n<li>\n<p>N=pq인 N을 만듭니다. (N = 187)</p>\n</li>\n<li>\n<p>Φ(N)=(p-1)(q-1)을 계산합니다. (16*10 = 160)</p>\n</li>\n<li>\n<p>공개키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 서로소인 수 e를 선택합니다. (e=7)</p>\n</li>\n<li>\n<p>개인키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 d*e mod 160 = 1인 수 를 구합니다. e가 7이었으므로</p>\n<p>7d mod 160 =1을 만족하는 d는 (160+1)/7 이므로, 23입니다.</p>\n</li>\n</ul>\n<p>따라서 결과적으로 공개키는 (187,7) / 개인키는 (187,23)이 됩니다.</p>\n<h3 id=\"암호화-공개키의-n과-e\" style=\"position:relative;\"><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\" aria-label=\"암호화 공개키의 n과 e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>암호화 (공개키의 n과 e)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C = M^e mod n</code></pre></div>\n<h3 id=\"복호화-개인키의-n과-d\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\" aria-label=\"복호화 개인키의 n과 d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복호화 (개인키의 n과 d)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">M = C^d mod n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%B0%A9%EC%8B%9D\">방식</a></li>\n<li><a href=\"#https\">HTTPS</a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\">블록체인</a></li>\n<li><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">RSA 알고리즘</a></li>\n<li><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\">암호화 (공개키의 n과 e)</a></li>\n<li><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\">복호화 (개인키의 n과 d)</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 05, 2021","title":"비대칭 암호화와 RSA 알고리즘","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/Asymmetric-Key/"}},"prev":{"id":"50fbdffb-984c-52a7-9d8b-dffac2378c54","html":"<p class=\"callout\"> 💡[프로그래머스] Level 2 전화번호 목록 | Python</p>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/42576\">문제 링크 및 출처</a></p>\n<p><img src=\"https://i.imgur.com/gO0Teg4.png\" alt=\"스크린샷 2021-04-09 오후 9.18.14\"></p>\n<h2 id=\"풀이과정\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\" aria-label=\"풀이과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이과정</h2>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>phone_book<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    phone_book<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>phone_book<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> phone_book<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>startswith<span class=\"token punctuation\">(</span>phone_book<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>  \n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span></code></pre></div>\n<p>해시문제인데 그냥 풀려버렸네요..\n전화번호부를 Sort 하게되면 문자열이기 때문에 앞 문자가 유니코드상으로 빠른 순서대로 정렬이됩니다.</p>\n<p>따라서 바로 뒤에 있는 것만 앞의 것으로 시작하는지(접두어) 확인하면 됩니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\">풀이과정</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 09, 2021","title":"프로그래머스 - Level 2 전화번호 목록 | Python","categories":"Algorithm","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/algorithm-2/"}},"site":{"siteMetadata":{"siteUrl":"https://codesik.github.io","comments":{"utterances":{"repo":"CodeSik/CodeSik.github.io"}}}}},"pageContext":{"slug":"/algorithm-1/","nextSlug":"/Asymmetric-Key/","prevSlug":"/algorithm-2/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}