{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/memory-management/",
    "result": {"data":{"cur":{"id":"0091b59f-cb42-526d-b604-f2d1efcadde7","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAH/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQME/9oADAMBAAIQAxAAAAGk7MwsAgP/xAAaEAABBQEAAAAAAAAAAAAAAAAAAQIRMUEQ/9oACAEBAAEFAsFvJHXJK8//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAABBQAAAAAAAAAAAAAAAAABABAgITL/2gAIAQEABj8CFLLCX//EAB4QAAIBAwUAAAAAAAAAAAAAAAABERAhQTFhobHR/9oACAEBAAE/IbZDZj0LFh0Ds1VFMlEm9wNy5Z//2gAMAwEAAgADAAAAEIjXw//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABgRAAIDAAAAAAAAAAAAAAAAAAABEBEx/9oACAECAQE/EBYUo//EAB8QAQACAgEFAQAAAAAAAAAAAAEAESFhMUFRcZHRsf/aAAgBAQABPxADRSK5TrGhKKNvsBQUYxeotU0Zc+WIoU1cCIex+EGDA4wM0PT5ERLWf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/80e3c/memory_management_img.jpg\"\n        srcset=\"/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/4ec73/memory_management_img.jpg 180w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/158ba/memory_management_img.jpg 360w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/80e3c/memory_management_img.jpg 720w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/acb04/memory_management_img.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[OS] 메모리 관리 기법과 가상 메모리\b</p>\n<blockquote>\n<p>본 포스팅은 한양대학교 컴퓨터소프트웨어학부 유민수 교수님의 운영체제 과목 강의 자료와 수업내용을 참고하였습니다.</p>\n</blockquote>\n<h2 id=\"메모리-관리-기법과-가상-메모리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"메모리 관리 기법과 가상 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법과 가상 메모리</h2>\n<p>가상메모리를 설명하기 위해서는 OS의 메모리 관리 기법에 대해서 알고있어야 합니다.</p>\n<p>CPU는 스케줄링 알고리즘을 통해서 메모리에 올릴 프로세스를 선택하게 됩니다. 이 과정에서 메모리의 관리는 OS에서 아주 중요한 부분이죠.</p>\n<h2 id=\"메모리-관리-기법의-두가지-목적\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%EB%AA%A9%EC%A0%81\" aria-label=\"메모리 관리 기법의 두가지 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법의 두가지 목적</h2>\n<ol>\n<li>프로세스 별로 하나의 단일하고 연속적이고, 보호가 되는 메모리의 공간을 할당하기 위함.</li>\n<li>실제 물리적 메모리 공간보다 더 많은 공간을 사용하기 위해서</li>\n</ol>\n<hr>\n<h2 id=\"메모리-관리-기법\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95\" aria-label=\"메모리 관리 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법</h2>\n<h3 id=\"연속적-address-binding\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\" aria-label=\"연속적 address binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속적 Address Binding</h3>\n<ul>\n<li>\n<p>Address Binding</p>\n<p>특정 메모리의 주소에 코드와 데이터를 적재하는 것.</p>\n</li>\n<li>\n<p>연속적인 메모리의 할당</p>\n<p>1번 목적이 기억나시나요?</p>\n<p>CPU는 연속적인 메모리의 할당을 요구합니다.\n<img src=\"/assets/IMG_0A580D86915E-1.jpeg\" alt=\"IMG_0A580D86915E-1\"></p>\n<p>이런식으로 프로세스간에 연속적으로 메모리를 할당하도록 하게 되어있고, 남는 공간은 hole로 비워두는 기법입니다. 다만 연속적 메모리 할당의 단점은 Hole이 너무 작게 형성 되는 경우 프로세스가 할당되지 않게 되어 낭비가 됩니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"비연속적-address-binding\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\" aria-label=\"비연속적 address binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속적 Address Binding</h3>\n<ul>\n<li>💡아이디어(Address Translation)<br>\n프로그램(CPU)은 Logical address를 사용하고, OS나 HW는 이를 하드웨어가 사용하는 Physical address로 변환합니다. 이렇게 Address Translation을 하게되면 비연속적인 메모리 할당이 가능해지며, Flexibility가 높아집니다.\n<br></li>\n<li>Address Translation<br>\n<code class=\"language-text\">Address Translation</code> 과정은 Logical Address를 Physical Address로 변환하는 과정이며, <code class=\"language-text\">MMU(Memory - Management Unit)</code>를 통해 수행할 수 있습니다. 이는 CPU와 Memory 사이에 있는 Relocation Register입니다. 하드웨어의 서포트를 받는것이죠.</li>\n</ul>\n<h4 id=\"비연속적으로-메모리를-할당하는-두가지-기법\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B2%95\" aria-label=\"비연속적으로 메모리를 할당하는 두가지 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속적으로 메모리를 할당하는 두가지 기법</h4>\n<p>그렇다면 비연속적으로 메모리를 할당하는 기법에 대해선 뭐가있을까요? 대표적으로는 두가지가 있습니다.</p>\n<ul>\n<li>\n<p>Segmentation</p>\n<p>메모리에 배정하는 단위를 <code class=\"language-text\">Segment</code>를 베이스로 하는것입니다. Process는 Text, Data, Stack등 다양한 영역으로 나눠져있는데, 각각의 영역을 Segment로 나눠서 메모리에 Address Translation 과정을 통해 할당하는 것입니다. 이렇게 되면 각 Segment가 다른 사이즈를 가지고 있다는 것을 알 수 있습니다.</p>\n</li>\n</ul>\n<p><img src=\"/assets/os3-1.png\" alt=\"os3-1\"></p>\n<blockquote>\n<p>프로세스의 구조<br></p>\n</blockquote>\n<p>사진 출처: <a href=\"https://zoomkoding.github.io/os/2019/04/20/os-3.html\">https://zoomkoding.github.io/os/2019/04/20/os-3.html</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">스케줄러에 의해 `Context Switching` 이 될 때 Process의 세그먼트 별 시작주소 값을 Memory Relocation Register에 저장하여 할당합니다.\n\n이렇게 되면 Hole의 크기가 작아도 배정이 가능해져서 문제가 줄어들게 됩니다. 다만 Page 저장 방식에 비해서 Hole이 어느정도 존재하게 되겠죠.\n\n![IMG_2A7BE3182EED-1](/assets/IMG_2A7BE3182EED-1.jpeg)</code></pre></div>\n<br>  \n<ul>\n<li>\n<p>Paging</p>\n<p><code class=\"language-text\">Page</code>란 동일한 일정 크기의 메모리 영역이며, 메모리에 Page 단위를 베이스로 하여 비연속적으로 할당하는 방법입니다. Process를 일정한 Page라는 단위로 나누는 것입니다.</p>\n<p>Page는 <code class=\"language-text\">Frame</code>이라는 용어와 연관되어 있는데, Page는 Virtual Address Space의 Block이고 Frame은 Physical Address Space의 Block입니다. 그래서 <code class=\"language-text\">VAS(Virtual Address Space)</code>에서 <code class=\"language-text\">PAS(Physical Address Space)</code>로의 Mapping을 통해 메모리에 할당합니다. 이때 Memory Relocation Register를 사용하는데, Segmentation에 비해서 굉장히 큰 비용이 듭니다. 그래서 OS에서는 <code class=\"language-text\">Page Table</code>을 통해 비용을 줄였는데, 이에 대해서는 다른 포스팅에서 다루겠습니다.</p>\n<p><img src=\"/assets/IMG_1293317E6A78-1.jpeg\" alt=\"IMG_1293317E6A78-1\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"demand-paging\" style=\"position:relative;\"><a href=\"#demand-paging\" aria-label=\"demand paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Demand Paging</h3>\n<p>모든 프로세스가 물리적인 메모리에 할당되는 방식은 너무 비효율적 입니다. 그래서 메모리 공간의 Utilization을 높이기 위해서 다양한 방법을 사용할 수 있습니다.</p>\n<ul>\n<li>Dynamic Loading</li>\n<li>Overlays</li>\n<li>Dynamic Linking</li>\n<li>Swapping</li>\n<li>Demand Paging</li>\n</ul>\n<p><code class=\"language-text\">Demand Paging</code>은 Paging 기법에 기안한 방법으로, Paging 기법은 모든 프로세스가 물리적인 메모리에 할당되어야 했으나 <code class=\"language-text\">Demand Paging</code>은 <span class=\"ud-red\">실행되는 것만 메모리에 저장하자.</span> 입니다.</p>\n<p>Demand Paging 메커니즘에 대해서 설명하기 위해서는 위에서 설명한 <code class=\"language-text\">Swapping</code> 에 대해서 알아야 하며, 간략히 말하자면 Page 단위로 Swap Out &#x26; In이 진행되는 것입니다.</p>\n<p>간단하게 Swapping에 대해서 알아봅시다.</p>\n<h4 id=\"swapping\" style=\"position:relative;\"><a href=\"#swapping\" aria-label=\"swapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swapping</h4>\n<p>메모리가 부족하게 되면 Active하지 않은 프로세스의 실행을 중단하고, 그 프로세스의 이미지(코드, 실행당시 Data)를 그대로 하드디스크에 씁니다. 이 과정이 <code class=\"language-text\">Swap Out</code>입니다.</p>\n<p>나중에 이 프로세스들이 Active되면 하드디스크에서 메모리로 복사하는데, 이 과정이 <code class=\"language-text\">Swap In</code>입니다.</p>\n<p>이 기법은 성능이 많이 느립니다. I/O 작업(Memory Access)을 해야하기 때문입니다.</p>\n<h5 id=\"demand-paging과-가상메모리\" style=\"position:relative;\"><a href=\"#demand-paging%EA%B3%BC-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"demand paging과 가상메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Demand Paging과 가상메모리</h5>\n<p>위의 Swap Out &#x26; In을 Page 단위로 하는것입니다. Swapping과 다르게 Page단위로 Swapping이 일어나기 때문에 Process가 종료되지 않습니다.</p>\n<p>여기서 가상메모리에 대한 내용을 이해할 수가 있습니다.</p>\n<p>만약에 메인메모리의 크기가 100MB이고, 200MB크기의 프로세스를 실행시키려면 불가능할 것 입니다. 하지만 위에서 말한 Page 단위로 프로세스를 쪼개고, 필요한 Page만 메모리에 적재하게 되면 프로세스를 실행시킬 수 있는 것입니다. 이게 가상메모리의 개념입니다. 실제 물리적 메모리의 제약을 없애고 더 많은 프로세스를 실행시킬 수 있는 것입니다.\n<img src=\"/assets/IMG_D3F891F9DE9F-1.jpeg\" alt=\"IMG_D3F891F9DE9F-1\"></p>\n<p>Swapping의 개념과 거의 비슷하다고 보시면 됩니다. 그 단위가 Page라고 생각하면 됩니다.</p>\n<h4 id=\"active한-page를-판별하는-방법\" style=\"position:relative;\"><a href=\"#active%ED%95%9C-page%EB%A5%BC-%ED%8C%90%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"active한 page를 판별하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Active한 Page를 판별하는 방법</h4>\n<p>Swap Out &#x26; In이 Active한 Page를 구별해서 일어난다는 것은 알았는데, 어떻게 아는걸까요?\nDemand Paging의 Trigger 역할을 하는 메커니즘은 <code class=\"language-text\">Page Fault</code>입니다.</p>\n<p>Page Table은 Logical Memory(Page)와 Physical Memory(Frame)의 매핑 정보를 담은 Table인데, 여기에 <code class=\"language-text\">valid - invalid Bit</code>을 추가합니다.(1bit)\n<img src=\"/assets/IMG_FDED4DEDC169-1.jpeg\" alt=\"IMG_FDED4DEDC169-1\"></p>\n<p>초기에는 모두 Invalid로 설정되어있고, 이 비트가 Page 주소를 참조하려 할때 Invalid면 Page Fault가 발생하여 Swap In 후 Valid한 것으로 바꿔줍니다.</p>\n<p>쉽게 말하자면 스케줄러가 Page 주소를 참조하려 한다는 것은 <code class=\"language-text\">Active</code>하다는 것입니다. 필요하다는(Demand) 것이죠. 그래서 Page Table을 살펴봤더니 아직 메모리에 적재가 안된것입니다. (Invalid) 그래서 Page Fault가 발생하고, Backing Store에서 페이지를 가져와 실제 메모리에 적재를 마치고 Valid로 바꿔줍니다.</p>\n<p>이렇게 되면 Logical Memory(Page)와 Physical Memory(Frame)의 매핑정보를 담은 Page Table에, 실제로 메모리에 적재되었는지 여부까지 알 수 있게 되는 것이죠.</p>\n<h4 id=\"page-replacement-frame이-다-배정되었을-때\" style=\"position:relative;\"><a href=\"#page-replacement-frame%EC%9D%B4-%EB%8B%A4-%EB%B0%B0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C\" aria-label=\"page replacement frame이 다 배정되었을 때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Replacement (Frame이 다 배정되었을 때)</h4>\n<p>이렇게 Swap In을 통해 물리 메모리에 모든 Page를 적재해서 공간이 없어졌는데 Page가 필요하게 되면 어떡할까요?</p>\n<p><code class=\"language-text\">Victim Frame</code>, 즉 희생할 이미 배정되어 있는 Frame을 선택해서 Swap Out하고 필요한 Page를 Swap In해야겠죠? 이 과정이 <code class=\"language-text\">Page Replacement</code>입니다.</p>\n<p><img src=\"/assets/IMG_FDED4DEDC169-1_oq2d50n87.jpeg\" alt=\"IMG_FDED4DEDC169-1\"></p>\n<p>정리하자면, Page Replacement의 과정은 다음과 같습니다.</p>\n<ol>\n<li>디스크에서 필요한 Page를 찾는다.</li>\n<li>Victim Frame을 선정하고 Swap out</li>\n<li>필요한 Page를 Swap In</li>\n</ol>\n<p>중요한 부분은 <code class=\"language-text\">Victim Frame</code>을 어떻게 선정해야 할것인가? 입니다. 알고리즘이 굉장히 중요하고 성능에 영향을 미칩니다. 오랫동안 사용되지 않은 Frame을 잘 선정하는 것이 중요하죠.</p>\n<p>본 포스팅에서는 자세히 설명하진 않지만 알고리즘에는 다음의 알고리즘들이 존재합니다.</p>\n<ul>\n<li>FIFO\n가장 먼저 들어온 Frame을 Victim 으로 선정</li>\n<li>Optimal Algorithm\n가장 이후에 참조될 Frame을 Victim 으로 선정</li>\n<li>LRU(Least Recently Used Algorithm)\n가장 오래전에 참조된 것을 Frame을 Victim 으로 선정</li>\n<li>Counting Algorithm\n시간이 아닌 <code class=\"language-text\">빈도</code>를 기준으로 Victim Frame 선정\n<ul>\n<li>LFU(Least Frequently Used)</li>\n<li>MFU(Most Frequently Used)</li>\n</ul>\n</li>\n</ul>\n<p>성능이 가장 좋은 것은 <code class=\"language-text\">Optimal Algorithm</code> 이지만, 미래에 어떤 Frame이 설정될 지는 알 수 없어서 구현이 어렵습니다. 그래서 성능을 비교하기 위해 사용합니다. <code class=\"language-text\">FIFO</code> 알고리즘은 성능이 안좋고, <code class=\"language-text\">LRU</code> 알고리즘은 가장 성능이 좋습니다. Counting Algorithm은 흔하지 않습니다.</p>\n<p><code class=\"language-text\">LRU</code> 알고리즘의 실제 구현 또한 어려우나 하드웨어를 추가적으로 사용하여 비슷한 알고리즘을 구현할 수 있습니다. (언제 참조됐는지를 기록할 Register)</p>\n<ul>\n<li>Reference Bit</li>\n<li>Additional Reference Bits</li>\n<li>Second Chance</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC\">메모리 관리 기법과 가상 메모리</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%EB%AA%A9%EC%A0%81\">메모리 관리 기법의 두가지 목적</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95\">메모리 관리 기법</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\">연속적 Address Binding</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\">비연속적 Address Binding</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B2%95\">비연속적으로 메모리를 할당하는 두가지 기법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#demand-paging\">Demand Paging</a></p>\n<ul>\n<li>\n<p><a href=\"#swapping\">Swapping</a></p>\n<ul>\n<li><a href=\"#demand-paging%EA%B3%BC-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\">Demand Paging과 가상메모리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#active%ED%95%9C-page%EB%A5%BC-%ED%8C%90%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">Active한 Page를 판별하는 방법</a></p>\n</li>\n<li>\n<p><a href=\"#page-replacement-frame%EC%9D%B4-%EB%8B%A4-%EB%B0%B0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C\">Page Replacement (Frame이 다 배정되었을 때)</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"본 포스팅은 한양대학교 컴퓨터소프트웨어학부 유민수 교수님의 운영체제 과목 강의 자료와 수업내용을 참고하였습니다. 메모리 관리 기법과 가상 메모리 가상메모리를 설명하기 위해서는 OS의 메모리 관리 기법에 대해서 알고있어야 합니다. CPU는 스케줄링 알고리즘을 통해서 메모리에 올릴 프로세스를 선택하게 됩니다. 이 과정에서 메모리의 관리는 OS에서 아주 중요한 부분이죠. 메모리 관리 기법의 두가지 목적 프로세스 별로 하나의 단일하고 연속적이고, 보호가 되는 메모리의 공간을 할당하기 위함. 실제 물리적 메모리 공간보다 더 많은 공간을 사용하기 위해서 메모리 관리 기법 연속적 Address Binding Address Binding 특정 메모리의 주소에 코드와 데이터를 적재하는 것. 연속적인 메모리의 할당 1번 목적이 기억나시나요? CPU는 연속적인 메모리의 할당을 요구합니다.\nIMG_0A580D86915E-1 이런식으로 프로세스간에 연속적으로 메모리를 할당하도록 하게 되어있고, 남는 공간…","frontmatter":{"date":"April 03, 2021","title":"메모리 관리 기법과 가상 메모리","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/memory-management/"}},"next":{"id":"b3b86876-3c39-543a-b3ba-ac40fea8b9df","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAH/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQME/9oADAMBAAIQAxAAAAGo7MwsAgP/xAAaEAABBQEAAAAAAAAAAAAAAAAAAQIRMUEQ/9oACAEBAAEFAsFvJHXJK8//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAABBQAAAAAAAAAAAAAAAAABABAgITL/2gAIAQEABj8CFLLCX//EAB0QAQACAgIDAAAAAAAAAAAAAAEAERAhMUFhodH/2gAIAQEAAT8h12FnX1DWmB05MIgq55vUW22f/9oADAMBAAIAAwAAABCo18P/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAYEQACAwAAAAAAAAAAAAAAAAAAARARMf/aAAgBAgEBPxAWFKP/xAAfEAEAAgEEAwEAAAAAAAAAAAABABEhMWFx0UFRkbH/2gAIAQEAAT8QA0UiuU8xoSijd3AUFGMXtFqmtHXliKFDmBEPo/CDBgaYGbD46iIlrP/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/d43efdd693dc97589b3bc4dd73e98f9e/80e3c/synchronization_img.jpg\"\n        srcset=\"/static/d43efdd693dc97589b3bc4dd73e98f9e/4ec73/synchronization_img.jpg 180w,\n/static/d43efdd693dc97589b3bc4dd73e98f9e/158ba/synchronization_img.jpg 360w,\n/static/d43efdd693dc97589b3bc4dd73e98f9e/80e3c/synchronization_img.jpg 720w,\n/static/d43efdd693dc97589b3bc4dd73e98f9e/acb04/synchronization_img.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[OS] 운영체제 프로세스 동기화 기법(Semaphore, Mutex)\b</p>\n<h2 id=\"동기화란\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%EB%9E%80\" aria-label=\"동기화란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기화란?</h2>\n<p>다수의 프로세스, 혹은 쓰레드에서 같은 공유 자원에 동시에 접근해야 하는 경우가 생깁니다.</p>\n<p>해당 경우에, 프로세스들이 같은 공유자원에 접근할 때 일관된 순서가 정해지지 않으면 데이터의 일관성이 깨지게 됩니다.</p>\n<p>그래서 프로세스가 동시에 같은 공유자원에 접근할 때 접근 순서를 보장해주는 과정이 <code class=\"language-text\">동기화</code>입니다.</p>\n<hr>\n<h3 id=\"race-condition\" style=\"position:relative;\"><a href=\"#race-condition\" aria-label=\"race condition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Race Condition</h3>\n<p>다수의 프로세스들이 공유 자원에 동시에 접근하고 있는 상황을 의미합니다.</p>\n<h3 id=\"critical-section\" style=\"position:relative;\"><a href=\"#critical-section\" aria-label=\"critical section permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Critical section</h3>\n<p>Race Condition에 놓인 프로세스들의 <code class=\"language-text\">Code</code> 영역, 즉 공유자원이 여러 프로세스들에 의해 동시 다발적으로 Access될 수 있는 영역입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n  Entry section\n    Critical section\n  Exit section\n    Remainder section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"critical-section-problem의-해결법\" style=\"position:relative;\"><a href=\"#critical-section-problem%EC%9D%98-%ED%95%B4%EA%B2%B0%EB%B2%95\" aria-label=\"critical section problem의 해결법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Critical Section Problem의 해결법</h3>\n<p>공유 자원의 접근 순서를 제어하기 위해서 만족해야할 <code class=\"language-text\">3가지의 조건</code>은 다음과 같습니다.</p>\n<ul>\n<li><strong>Mutual Exclusion(상호배제)</strong><br>\n하나의 프로세스, 혹은 쓰레드가 Critical Section에서 실행 중이면 다른 프로세스, 혹은 쓰레드가 접근하면 안된다.</li>\n<li><strong>Progress</strong><br>\n어떠한 경우에도 각 프로세스, 쓰레드가 자신이 실행해야할 작업을 만들어야 한다.</li>\n<li><strong>Bounded Waiting</strong><br>\n프로세스, 쓰레드가 Critical Section에 진입할 때, 기다리는 시간의 제한이 있어야한다.(무한정 X)</li>\n</ul>\n<p>그리고 <span class=\"ud-red\">Critical Section 부분은 최대한 줄이는 것</span>이 성능에 중요한 영향을 미칩니다.</p>\n<hr>\n<h2 id=\"동기화-기법의-종류\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"동기화 기법의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기화 기법의 종류</h2>\n<p>동기화 기법에는 많은 종류가 있습니다.</p>\n<p>하드웨어(레지스터)에서 제공하는 동기화 기법도 있고, 알고리즘을 작성하여 동기화를 할 수도 있으며, OS에서 제공하는 동기화 기법도 있습니다.</p>\n<ul>\n<li>Software Algorithm\n<ul>\n<li>Peterson’s Algorithm</li>\n<li>Dekker’s Algorithm</li>\n<li>Lamport’s Bakery Algorithm</li>\n</ul>\n</li>\n</ul>\n<br>\n* Hardware Support(Register)\n  * Interrupt Disabling\n  * Test-and-Set (Intel)\n  * Swap\n<br>\n* OS Support\n  * Semaphores\n  * Mutex\n<p>본 포스팅에서는 OS가 제공하는 동기화 기법인 Semaphores, Mutex에 대해서 기술합니다.</p>\n<hr>\n<h2 id=\"세마포어-semaphore\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-semaphore\" aria-label=\"세마포어 semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세마포어 (Semaphore)</h2>\n<p>세마포어는 먼저 구현 측면에 따라, 그리고 사용 측면에 따라서 다음과 같이 분류할 수 있습니다.</p>\n<ul>\n<li>구현 관점\n<ul>\n<li>Busy Waiting Semaphore(SpinLock)</li>\n<li>Blocking Semaphore</li>\n</ul>\n</li>\n<li>사용 관점\n<ul>\n<li>Binary</li>\n<li>Counting</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"busy-waiting-semaphorespinlock\" style=\"position:relative;\"><a href=\"#busy-waiting-semaphorespinlock\" aria-label=\"busy waiting semaphorespinlock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Busy Waiting Semaphore(SpinLock)</h3>\n<p>세마포어는 <code class=\"language-text\">정수</code> 변수이며, 임의로 접근할 수 없고 2가지의 Operation(API)으로 접근할 수 있습니다. 각 함수에 대한 수도코드는 다음과 같습니다.</p>\n<ul>\n<li><strong>P (Wait)</strong>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>Semaphore S<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n  <span class=\"token keyword\">while</span> S<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span>\n    <span class=\"token keyword\">do</span> No<span class=\"token operator\">-</span>op<span class=\"token punctuation\">;</span>\n  S <span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></code></pre></div>\nS가 음수면 아무것도 진행하지 않고 기다리며, S가 양수면 S를 감소시킵니다.</li>\n<li><strong>S (Signal)</strong>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">signal(Semaphore S):\n  S++;</code></pre></div>\n</li>\n</ul>\n<p>두 API는 Atomic하게 작동합니다.</p>\n<p>예제를 한번 보겠습니다.</p>\n<ul>\n<li>공유 자원: Semaphore S; (Initially S = 1)</li>\n<li>Process Pi\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">do</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Critical Section\n  <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Remainder Section\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<p>프로세스들이 해당 코드를 가지고 있다고 합시다.</p>\n<p>맨 처음 프로세스 P0가 접근했을 때 S의 값은 1이므로 wait(S) 함수에 접근했을 때 While문 조건에 걸리지 않고, S를 0으로 만든 후 <code class=\"language-text\">Critical Section</code>에 진입하게 됩니다.</p>\n<p>P0가 진입한 이후 P1이 임계영역에 진입하려고 할 때 wait(S)에서 S가 0이기 때문에 P0가 임계영역에서 작업을 마치고 signal(S) 함수에 들어가 S=1로 변경해야만 반복문을 빠져나올 수 있습니다. 그렇게 되면 P1이 임계영역에 진입할 수 있겠죠.</p>\n<p>정리하자면 S=0일때는 한 프로세스가 자원을 점유하고 있으므로 다른 프로세스의 접근을 막는 것이며, 자원 점유가 끝나면 Signal(S) 연산을 실행하여 자원을 반납했다는 신호를 보내는 것입니다.</p>\n<h3 id=\"blocking-semaphore\" style=\"position:relative;\"><a href=\"#blocking-semaphore\" aria-label=\"blocking semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Blocking Semaphore</h3>\n<p>위에서 봤던 P,S 연산의 수도코드는 기다리는 동안 무한루프를 돌기 때문에, CPU를 낭비한다는 단점이 있습니다. 위에서 사용한 Semaphore는 <code class=\"language-text\">Busy Waiting Semaphore(SpinLock)</code>입니다. 해당 방법은 짧은 시간동안만 사용할 때는 유용하게 쓰일 수 있습니다.</p>\n<p>이 단점을 해결하기 위한 방법은 <code class=\"language-text\">Blocking</code>입니다. 강제로 프로세스의 상태를 변경시키는 것으로 구현하여 <span class=\"ud-red\">While Loop을 없애주는 것</span> 입니다.</p>\n<p>Semaphore를 다음과 같이 정의해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> value<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">process</span> <span class=\"token operator\">*</span>L<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Critical Section에 들어가길 원하는 프로세스들의 모음을 Linked List로 저장</span>\n<span class=\"token punctuation\">}</span>semaphore<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><strong>P - Blocking(Wait)</strong>\n프로세스 상태: Running —> Waiting\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>Semaphore S<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n  S<span class=\"token punctuation\">.</span>value <span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">.</span>value <span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    프로세스를 S<span class=\"token punctuation\">.</span>L에 추가\n    block<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Running -> Waiting</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\nS는 음수가 될 수 있으며, S의 절댓값은 기다리고 있는 프로세스를 의미합니다.</li>\n<li><strong>S - Wake Up(Signal)</strong>\n프로세스 상태: Waiting —> (Ready) —> Running\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>Semaphore S<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n  S<span class=\"token punctuation\">.</span>value <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">.</span>value <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    S<span class=\"token punctuation\">.</span>L에서 process P 하나를 제거<span class=\"token punctuation\">(</span>제일 앞<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Wating -> (Ready) -> Running</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p>기다리고 있는 프로세스의 목록은 <code class=\"language-text\">FIFO</code>로 구현하여 먼저 들어온 프로세스가 먼저 접근하도록 순서를 정해줍니다.</p>\n<p>위에서 볼 수 있듯 세마포어는 음수의 값을 가질 수 있고, 이에 대한 절댓값은 기다리고 있는 프로세스의 갯수라고 생각하면 됩니다.</p>\n<hr>\n<h3 id=\"binary-semaphore\" style=\"position:relative;\"><a href=\"#binary-semaphore\" aria-label=\"binary semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Binary Semaphore</h3>\n<p>세마포어가 <span class=\"ud-red\">오직 <strong>0</strong> 또는 <strong>1</strong> 의 값만 가질 수 있으며</span>, 초기에는 1로 초기화 되어있습니다.\nBlocking Semaphore는 음수의 값을 가지지만 Binary Semaphore라고 부르긴 합니다. 1을 넘지 않기 때문입니다.</p>\n<h3 id=\"counting-semaphore\" style=\"position:relative;\"><a href=\"#counting-semaphore\" aria-label=\"counting semaphore permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Counting Semaphore</h3>\n<p>세마포어의 값이 <span class=\"ud-red\">1을 초과할 수 있습니다.</span>\n만약 S의 값이 4라면, Critical Section에 최대 4개가 접근 가능한 것입니다.</p>\n<h2 id=\"뮤텍스-mutex\" style=\"position:relative;\"><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4-mutex\" aria-label=\"뮤텍스 mutex permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뮤텍스 (Mutex)</h2>\n<p>뮤텍스는 세마포어와 같이 OS에서 제공하는 동기화 기법 중 하나입니다. Binary Semaphore와 같이 1과, 0의 값을 가집니다.</p>\n<p>Semaphore와 비슷하게, 임계영역에 들어갈 때는 <code class=\"language-text\">Lock</code>을 걸어서 다른 프로세스, 쓰레드가 접근하지 못하도록 하고 임계영역에서 나올 때 <code class=\"language-text\">Unlock</code>합니다.</p>\n<h2 id=\"뮤텍스와-세마포어의-차이\" style=\"position:relative;\"><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"뮤텍스와 세마포어의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뮤텍스와 세마포어의 차이</h2>\n<ul>\n<li>\n<p>세마포어는 Counting Semaphore등을 사용하면 Semaphore의 변수 크기 만큼 프로세스, 쓰레드가 접근할 수 있으나 뮤텍스는 오직 1개의 프로세스, 쓰레드만 접근할 수 있습니다.</p>\n</li>\n<li>\n<p>세마포어는 수행중인 프로세스가 아닌 <span class=\"ud-red\">다른 프로세스에서 세마포어 해제가 가능합니다.</span> 하지만 뮤텍스는 직접 <code class=\"language-text\">Lock</code>을 건 프로세스만 <code class=\"language-text\">UnLock</code>을 할 수 있습니다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94%EB%9E%80\">동기화란?</a></p>\n<ul>\n<li><a href=\"#race-condition\">Race Condition</a></li>\n<li><a href=\"#critical-section\">Critical section</a></li>\n<li><a href=\"#critical-section-problem%EC%9D%98-%ED%95%B4%EA%B2%B0%EB%B2%95\">Critical Section Problem의 해결법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95%EC%9D%98-%EC%A2%85%EB%A5%98\">동기화 기법의 종류</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-semaphore\">세마포어 (Semaphore)</a></p>\n<ul>\n<li><a href=\"#busy-waiting-semaphorespinlock\">Busy Waiting Semaphore(SpinLock)</a></li>\n<li><a href=\"#blocking-semaphore\">Blocking Semaphore</a></li>\n<li><a href=\"#binary-semaphore\">Binary Semaphore</a></li>\n<li><a href=\"#counting-semaphore\">Counting Semaphore</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4-mutex\">뮤텍스 (Mutex)</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4\">뮤텍스와 세마포어의 차이</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 02, 2021","title":"운영체제 프로세스 동기화 기법(Semaphore, Mutex)","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/synchronization/"}},"prev":{"id":"013b0786-94ad-550c-8f21-030742b9273e","html":"<p class=\"callout\"> 💡[JAVA] JVM의 Garbage Collection </p>\n<h1 id=\"garbage-collection\" style=\"position:relative;\"><a href=\"#garbage-collection\" aria-label=\"garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collection</h1>\n<p>C/C++ 에서는 메모리를 개발자가 명시적으로 해제하지만 JVM 기반 어플리케이션에서는 명시적으로 해제를 하지 않습니다. JVM의 Garbage Collector가 더이상 사용되지 않는 인스턴스를 찾아내서 메모리를 삭제하는 행위를 합니다.</p>\n<hr>\n<h2 id=\"동작-방식\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작 방식</h2>\n<h3 id=\"stop-the-world\" style=\"position:relative;\"><a href=\"#stop-the-world\" aria-label=\"stop the world permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop The World</h3>\n<p>앞서 말씀드렸듯 <code class=\"language-text\">Garbage Collector</code>는 자동으로 JVM이 판단하여 사용되지 않는 인스턴스의 할당을 해제하는 역할을 합니다. 다만 메모리를 해제하기 위해서는 자바 어플리케이션의 GC를 실행하기 위한 쓰레드를 제외하고 모두 멈추게 되고, GC가 완료된 후에야 다른 쓰레드가 작동하게 됩니다. 이러한 상태를 <code class=\"language-text\">Stop The World</code>라고 합니다.</p>\n<h3 id=\"mark-and-sweep\" style=\"position:relative;\"><a href=\"#mark-and-sweep\" aria-label=\"mark and sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark and Sweep</h3>\n<p><code class=\"language-text\">Stop The World</code>  상태에서 GC는 스택의 모든 변수나 Reachable 객체를 스캔한다. 여기서 사용되고 있는 메모리를 찾아내는 과정이 <code class=\"language-text\">Mark</code> , 식별되지 않은 객체를 메모리에서 제거하는 과정이 <code class=\"language-text\">Sweep</code> 이다.</p>\n<h3 id=\"gc-튜닝\" style=\"position:relative;\"><a href=\"#gc-%ED%8A%9C%EB%8B%9D\" aria-label=\"gc 튜닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC 튜닝</h3>\n<p>GC 튜닝이란 이러한 Stop The World 상태의 시간을 최소한으로 하는 작업이라고 보시면 됩니다.</p>\n<h2 id=\"sun-jvm의-young-generation--old-generation\" style=\"position:relative;\"><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\" aria-label=\"sun jvm의 young generation  old generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sun JVM의 Young Generation / Old Generation</h2>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code>: 생명 주기가 짧은 객체를 GC의 대상으로 하는 영역</p>\n<p><code class=\"language-text\">Old Generation(Major GC)</code>: 생명 주기가 긴 객체를 GC의 대상으로 하는 영역</p>\n<p>일반적인 JVM Application은 생명주기가 짧은 객체가 훨씬 많습니다. 그래서 Sun JVM의 <code class=\"language-text\">Generation Heap</code> 은 Young Generation에 속한 객체의 빠른 생성과 제거를 보장하는 성격을 지니고 있습니다.</p>\n<h3 id=\"young-generation-동작-방식\" style=\"position:relative;\"><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"young generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young Generation 동작 방식</h3>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code> 는 3개의 영역으로 나뉘어 집니다.</p>\n<ul>\n<li>Eden 영역</li>\n<li>2개의 Survivor 영역</li>\n</ul>\n<p>객체가 처음 생성되면  <code class=\"language-text\">Eden</code> 영역에 할당이 됩니다. 계속 할당이 되다가  <code class=\"language-text\">Eden</code> 영역이 꽉차게 되면 Minor GC 가 활성화 됩니다. 이 때 Stop The wolrd 상태가 되는거죠. 사용되지 않은 객체의 메모리를 해제하고 남아있는 <code class=\"language-text\">Eden</code> 영역의 객체들을 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다.</p>\n<p><code class=\"language-text\">Survivor</code> 영역마저 꽉차게 된다면 <code class=\"language-text\">Survivor</code> 영역에서 살아남은 객체를 다른 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다. <code class=\"language-text\">Survivor</code> 영역 중 하나는 반드시 빈 상태를 유지해야 합니다.</p>\n<p>이 과정들을 반복하여 계속 살아남은 객체는 <code class=\"language-text\">Old Generation</code> 으로 Promotion(이동) 됩니다.</p>\n<h3 id=\"old-generation-동작-방식\" style=\"position:relative;\"><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"old generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old Generation 동작 방식</h3>\n<p><code class=\"language-text\">Old Generation(Major GC)</code> 에서 <code class=\"language-text\">Major GC</code> 가 활성화 되기 위해선 해당 영역에 객체가 꽉 차야합니다. 다만 Major GC는 굉장히 오래걸리는 작업입니다. Young 영역보다 크기가 클 뿐더러, Young 영역의 객체를 참조하고 있을 수도 있기 때문입니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">동작 방식</a></p>\n<ul>\n<li><a href=\"#stop-the-world\">Stop The World</a></li>\n<li><a href=\"#mark-and-sweep\">Mark and Sweep</a></li>\n<li><a href=\"#gc-%ED%8A%9C%EB%8B%9D\">GC 튜닝</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\">Sun JVM의 Young Generation / Old Generation</a></p>\n<ul>\n<li><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Young Generation 동작 방식</a></li>\n<li><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Old Generation 동작 방식</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2021","title":"JVM의 Garbage Collection","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/java-gc/"}},"site":{"siteMetadata":{"siteUrl":"https://codesik.github.io","comments":{"utterances":{"repo":"CodeSik/CodeSik.github.io"}}}}},"pageContext":{"slug":"/memory-management/","nextSlug":"/synchronization/","prevSlug":"/java-gc/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}