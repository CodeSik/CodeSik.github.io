{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/java-gc/",
    "result": {"data":{"cur":{"id":"013b0786-94ad-550c-8f21-030742b9273e","html":"<p class=\"callout\"> 💡[JAVA] JVM의 Garbage Collection </p>\n<h1 id=\"garbage-collection\" style=\"position:relative;\"><a href=\"#garbage-collection\" aria-label=\"garbage collection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collection</h1>\n<p>C/C++ 에서는 메모리를 개발자가 명시적으로 해제하지만 JVM 기반 어플리케이션에서는 명시적으로 해제를 하지 않습니다. JVM의 Garbage Collector가 더이상 사용되지 않는 인스턴스를 찾아내서 메모리를 삭제하는 행위를 합니다.</p>\n<hr>\n<h2 id=\"동작-방식\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작 방식</h2>\n<h3 id=\"stop-the-world\" style=\"position:relative;\"><a href=\"#stop-the-world\" aria-label=\"stop the world permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop The World</h3>\n<p>앞서 말씀드렸듯 <code class=\"language-text\">Garbage Collector</code>는 자동으로 JVM이 판단하여 사용되지 않는 인스턴스의 할당을 해제하는 역할을 합니다. 다만 메모리를 해제하기 위해서는 자바 어플리케이션의 GC를 실행하기 위한 쓰레드를 제외하고 모두 멈추게 되고, GC가 완료된 후에야 다른 쓰레드가 작동하게 됩니다. 이러한 상태를 <code class=\"language-text\">Stop The World</code>라고 합니다.</p>\n<h3 id=\"mark-and-sweep\" style=\"position:relative;\"><a href=\"#mark-and-sweep\" aria-label=\"mark and sweep permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mark and Sweep</h3>\n<p><code class=\"language-text\">Stop The World</code>  상태에서 GC는 스택의 모든 변수나 Reachable 객체를 스캔한다. 여기서 사용되고 있는 메모리를 찾아내는 과정이 <code class=\"language-text\">Mark</code> , 식별되지 않은 객체를 메모리에서 제거하는 과정이 <code class=\"language-text\">Sweep</code> 이다.</p>\n<h3 id=\"gc-튜닝\" style=\"position:relative;\"><a href=\"#gc-%ED%8A%9C%EB%8B%9D\" aria-label=\"gc 튜닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GC 튜닝</h3>\n<p>GC 튜닝이란 이러한 Stop The World 상태의 시간을 최소한으로 하는 작업이라고 보시면 됩니다.</p>\n<h2 id=\"sun-jvm의-young-generation--old-generation\" style=\"position:relative;\"><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\" aria-label=\"sun jvm의 young generation  old generation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sun JVM의 Young Generation / Old Generation</h2>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code>: 생명 주기가 짧은 객체를 GC의 대상으로 하는 영역</p>\n<p><code class=\"language-text\">Old Generation(Major GC)</code>: 생명 주기가 긴 객체를 GC의 대상으로 하는 영역</p>\n<p>일반적인 JVM Application은 생명주기가 짧은 객체가 훨씬 많습니다. 그래서 Sun JVM의 <code class=\"language-text\">Generation Heap</code> 은 Young Generation에 속한 객체의 빠른 생성과 제거를 보장하는 성격을 지니고 있습니다.</p>\n<h3 id=\"young-generation-동작-방식\" style=\"position:relative;\"><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"young generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Young Generation 동작 방식</h3>\n<p><code class=\"language-text\">Young Generation(Minor GC)</code> 는 3개의 영역으로 나뉘어 집니다.</p>\n<ul>\n<li>Eden 영역</li>\n<li>2개의 Survivor 영역</li>\n</ul>\n<p>객체가 처음 생성되면  <code class=\"language-text\">Eden</code> 영역에 할당이 됩니다. 계속 할당이 되다가  <code class=\"language-text\">Eden</code> 영역이 꽉차게 되면 Minor GC 가 활성화 됩니다. 이 때 Stop The wolrd 상태가 되는거죠. 사용되지 않은 객체의 메모리를 해제하고 남아있는 <code class=\"language-text\">Eden</code> 영역의 객체들을 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다.</p>\n<p><code class=\"language-text\">Survivor</code> 영역마저 꽉차게 된다면 <code class=\"language-text\">Survivor</code> 영역에서 살아남은 객체를 다른 <code class=\"language-text\">Survivor</code> 영역으로 옮깁니다. <code class=\"language-text\">Survivor</code> 영역 중 하나는 반드시 빈 상태를 유지해야 합니다.</p>\n<p>이 과정들을 반복하여 계속 살아남은 객체는 <code class=\"language-text\">Old Generation</code> 으로 Promotion(이동) 됩니다.</p>\n<h3 id=\"old-generation-동작-방식\" style=\"position:relative;\"><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"old generation 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Old Generation 동작 방식</h3>\n<p><code class=\"language-text\">Old Generation(Major GC)</code> 에서 <code class=\"language-text\">Major GC</code> 가 활성화 되기 위해선 해당 영역에 객체가 꽉 차야합니다. 다만 Major GC는 굉장히 오래걸리는 작업입니다. Young 영역보다 크기가 클 뿐더러, Young 영역의 객체를 참조하고 있을 수도 있기 때문입니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">동작 방식</a></p>\n<ul>\n<li><a href=\"#stop-the-world\">Stop The World</a></li>\n<li><a href=\"#mark-and-sweep\">Mark and Sweep</a></li>\n<li><a href=\"#gc-%ED%8A%9C%EB%8B%9D\">GC 튜닝</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#sun-jvm%EC%9D%98-young-generation--old-generation\">Sun JVM의 Young Generation / Old Generation</a></p>\n<ul>\n<li><a href=\"#young-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Young Generation 동작 방식</a></li>\n<li><a href=\"#old-generation-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">Old Generation 동작 방식</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Garbage Collection C/C++ 에서는 메모리를 개발자가 명시적으로 해제하지만 JVM 기반 어플리케이션에서는 명시적으로 해제를 하지 않습니다. JVM의 Garbage Collector가 더이상 사용되지 않는 인스턴스를 찾아내서 메모리를 삭제하는 행위를 합니다. 동작 방식 Stop The World 앞서 말씀드렸듯 는 자동으로 JVM이 판단하여 사용되지 않는 인스턴스의 할당을 해제하는 역할을 합니다. 다만 메모리를 해제하기 위해서는 자바 어플리케이션의 GC를 실행하기 위한 쓰레드를 제외하고 모두 멈추게 되고, GC가 완료된 후에야 다른 쓰레드가 작동하게 됩니다. 이러한 상태를 라고 합니다. Mark and Sweep   상태에서 GC는 스택의 모든 변수나 Reachable 객체를 스캔한다. 여기서 사용되고 있는 메모리를 찾아내는 과정이  , 식별되지 않은 객체를 메모리에서 제거하는 과정이  이다. GC 튜닝 GC 튜닝이란 이러한 Stop The World 상태의 시간을 …","frontmatter":{"date":"April 04, 2021","title":"JVM의 Garbage Collection","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/java-gc/"}},"next":{"id":"0091b59f-cb42-526d-b604-f2d1efcadde7","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAH/xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQME/9oADAMBAAIQAxAAAAGk7MwsAgP/xAAaEAABBQEAAAAAAAAAAAAAAAAAAQIRMUEQ/9oACAEBAAEFAsFvJHXJK8//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAZEAABBQAAAAAAAAAAAAAAAAABABAgITL/2gAIAQEABj8CFLLCX//EAB4QAAIBAwUAAAAAAAAAAAAAAAABERAhQTFhobHR/9oACAEBAAE/IbZDZj0LFh0Ds1VFMlEm9wNy5Z//2gAMAwEAAgADAAAAEIjXw//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QH//EABgRAAIDAAAAAAAAAAAAAAAAAAABEBEx/9oACAECAQE/EBYUo//EAB8QAQACAgEFAQAAAAAAAAAAAAEAESFhMUFRcZHRsf/aAAgBAQABPxADRSK5TrGhKKNvsBQUYxeotU0Zc+WIoU1cCIex+EGDA4wM0PT5ERLWf//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/80e3c/memory_management_img.jpg\"\n        srcset=\"/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/4ec73/memory_management_img.jpg 180w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/158ba/memory_management_img.jpg 360w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/80e3c/memory_management_img.jpg 720w,\n/static/aca4c79ae3d3c0550bf2aa7e1e0448fd/acb04/memory_management_img.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[OS] 메모리 관리 기법과 가상 메모리\b</p>\n<blockquote>\n<p>본 포스팅은 한양대학교 컴퓨터소프트웨어학부 유민수 교수님의 운영체제 과목 강의 자료와 수업내용을 참고하였습니다.</p>\n</blockquote>\n<h2 id=\"메모리-관리-기법과-가상-메모리\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"메모리 관리 기법과 가상 메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법과 가상 메모리</h2>\n<p>가상메모리를 설명하기 위해서는 OS의 메모리 관리 기법에 대해서 알고있어야 합니다.</p>\n<p>CPU는 스케줄링 알고리즘을 통해서 메모리에 올릴 프로세스를 선택하게 됩니다. 이 과정에서 메모리의 관리는 OS에서 아주 중요한 부분이죠.</p>\n<h2 id=\"메모리-관리-기법의-두가지-목적\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%EB%AA%A9%EC%A0%81\" aria-label=\"메모리 관리 기법의 두가지 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법의 두가지 목적</h2>\n<ol>\n<li>프로세스 별로 하나의 단일하고 연속적이고, 보호가 되는 메모리의 공간을 할당하기 위함.</li>\n<li>실제 물리적 메모리 공간보다 더 많은 공간을 사용하기 위해서</li>\n</ol>\n<hr>\n<h2 id=\"메모리-관리-기법\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95\" aria-label=\"메모리 관리 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 관리 기법</h2>\n<h3 id=\"연속적-address-binding\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\" aria-label=\"연속적 address binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연속적 Address Binding</h3>\n<ul>\n<li>\n<p>Address Binding</p>\n<p>특정 메모리의 주소에 코드와 데이터를 적재하는 것.</p>\n</li>\n<li>\n<p>연속적인 메모리의 할당</p>\n<p>1번 목적이 기억나시나요?</p>\n<p>CPU는 연속적인 메모리의 할당을 요구합니다.\n<img src=\"/assets/IMG_0A580D86915E-1.jpeg\" alt=\"IMG_0A580D86915E-1\"></p>\n<p>이런식으로 프로세스간에 연속적으로 메모리를 할당하도록 하게 되어있고, 남는 공간은 hole로 비워두는 기법입니다. 다만 연속적 메모리 할당의 단점은 Hole이 너무 작게 형성 되는 경우 프로세스가 할당되지 않게 되어 낭비가 됩니다.</p>\n</li>\n</ul>\n<hr>\n<h3 id=\"비연속적-address-binding\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\" aria-label=\"비연속적 address binding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속적 Address Binding</h3>\n<ul>\n<li>💡아이디어(Address Translation)<br>\n프로그램(CPU)은 Logical address를 사용하고, OS나 HW는 이를 하드웨어가 사용하는 Physical address로 변환합니다. 이렇게 Address Translation을 하게되면 비연속적인 메모리 할당이 가능해지며, Flexibility가 높아집니다.\n<br></li>\n<li>Address Translation<br>\n<code class=\"language-text\">Address Translation</code> 과정은 Logical Address를 Physical Address로 변환하는 과정이며, <code class=\"language-text\">MMU(Memory - Management Unit)</code>를 통해 수행할 수 있습니다. 이는 CPU와 Memory 사이에 있는 Relocation Register입니다. 하드웨어의 서포트를 받는것이죠.</li>\n</ul>\n<h4 id=\"비연속적으로-메모리를-할당하는-두가지-기법\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B2%95\" aria-label=\"비연속적으로 메모리를 할당하는 두가지 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비연속적으로 메모리를 할당하는 두가지 기법</h4>\n<p>그렇다면 비연속적으로 메모리를 할당하는 기법에 대해선 뭐가있을까요? 대표적으로는 두가지가 있습니다.</p>\n<ul>\n<li>\n<p>Segmentation</p>\n<p>메모리에 배정하는 단위를 <code class=\"language-text\">Segment</code>를 베이스로 하는것입니다. Process는 Text, Data, Stack등 다양한 영역으로 나눠져있는데, 각각의 영역을 Segment로 나눠서 메모리에 Address Translation 과정을 통해 할당하는 것입니다. 이렇게 되면 각 Segment가 다른 사이즈를 가지고 있다는 것을 알 수 있습니다.</p>\n</li>\n</ul>\n<p><img src=\"/assets/os3-1.png\" alt=\"os3-1\"></p>\n<blockquote>\n<p>프로세스의 구조<br></p>\n</blockquote>\n<p>사진 출처: <a href=\"https://zoomkoding.github.io/os/2019/04/20/os-3.html\">https://zoomkoding.github.io/os/2019/04/20/os-3.html</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">스케줄러에 의해 `Context Switching` 이 될 때 Process의 세그먼트 별 시작주소 값을 Memory Relocation Register에 저장하여 할당합니다.\n\n이렇게 되면 Hole의 크기가 작아도 배정이 가능해져서 문제가 줄어들게 됩니다. 다만 Page 저장 방식에 비해서 Hole이 어느정도 존재하게 되겠죠.\n\n![IMG_2A7BE3182EED-1](/assets/IMG_2A7BE3182EED-1.jpeg)</code></pre></div>\n<br>  \n<ul>\n<li>\n<p>Paging</p>\n<p><code class=\"language-text\">Page</code>란 동일한 일정 크기의 메모리 영역이며, 메모리에 Page 단위를 베이스로 하여 비연속적으로 할당하는 방법입니다. Process를 일정한 Page라는 단위로 나누는 것입니다.</p>\n<p>Page는 <code class=\"language-text\">Frame</code>이라는 용어와 연관되어 있는데, Page는 Virtual Address Space의 Block이고 Frame은 Physical Address Space의 Block입니다. 그래서 <code class=\"language-text\">VAS(Virtual Address Space)</code>에서 <code class=\"language-text\">PAS(Physical Address Space)</code>로의 Mapping을 통해 메모리에 할당합니다. 이때 Memory Relocation Register를 사용하는데, Segmentation에 비해서 굉장히 큰 비용이 듭니다. 그래서 OS에서는 <code class=\"language-text\">Page Table</code>을 통해 비용을 줄였는데, 이에 대해서는 다른 포스팅에서 다루겠습니다.</p>\n<p><img src=\"/assets/IMG_1293317E6A78-1.jpeg\" alt=\"IMG_1293317E6A78-1\"></p>\n</li>\n</ul>\n<hr>\n<h3 id=\"demand-paging\" style=\"position:relative;\"><a href=\"#demand-paging\" aria-label=\"demand paging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Demand Paging</h3>\n<p>모든 프로세스가 물리적인 메모리에 할당되는 방식은 너무 비효율적 입니다. 그래서 메모리 공간의 Utilization을 높이기 위해서 다양한 방법을 사용할 수 있습니다.</p>\n<ul>\n<li>Dynamic Loading</li>\n<li>Overlays</li>\n<li>Dynamic Linking</li>\n<li>Swapping</li>\n<li>Demand Paging</li>\n</ul>\n<p><code class=\"language-text\">Demand Paging</code>은 Paging 기법에 기안한 방법으로, Paging 기법은 모든 프로세스가 물리적인 메모리에 할당되어야 했으나 <code class=\"language-text\">Demand Paging</code>은 <span class=\"ud-red\">실행되는 것만 메모리에 저장하자.</span> 입니다.</p>\n<p>Demand Paging 메커니즘에 대해서 설명하기 위해서는 위에서 설명한 <code class=\"language-text\">Swapping</code> 에 대해서 알아야 하며, 간략히 말하자면 Page 단위로 Swap Out &#x26; In이 진행되는 것입니다.</p>\n<p>간단하게 Swapping에 대해서 알아봅시다.</p>\n<h4 id=\"swapping\" style=\"position:relative;\"><a href=\"#swapping\" aria-label=\"swapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Swapping</h4>\n<p>메모리가 부족하게 되면 Active하지 않은 프로세스의 실행을 중단하고, 그 프로세스의 이미지(코드, 실행당시 Data)를 그대로 하드디스크에 씁니다. 이 과정이 <code class=\"language-text\">Swap Out</code>입니다.</p>\n<p>나중에 이 프로세스들이 Active되면 하드디스크에서 메모리로 복사하는데, 이 과정이 <code class=\"language-text\">Swap In</code>입니다.</p>\n<p>이 기법은 성능이 많이 느립니다. I/O 작업(Memory Access)을 해야하기 때문입니다.</p>\n<h5 id=\"demand-paging과-가상메모리\" style=\"position:relative;\"><a href=\"#demand-paging%EA%B3%BC-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\" aria-label=\"demand paging과 가상메모리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Demand Paging과 가상메모리</h5>\n<p>위의 Swap Out &#x26; In을 Page 단위로 하는것입니다. Swapping과 다르게 Page단위로 Swapping이 일어나기 때문에 Process가 종료되지 않습니다.</p>\n<p>여기서 가상메모리에 대한 내용을 이해할 수가 있습니다.</p>\n<p>만약에 메인메모리의 크기가 100MB이고, 200MB크기의 프로세스를 실행시키려면 불가능할 것 입니다. 하지만 위에서 말한 Page 단위로 프로세스를 쪼개고, 필요한 Page만 메모리에 적재하게 되면 프로세스를 실행시킬 수 있는 것입니다. 이게 가상메모리의 개념입니다. 실제 물리적 메모리의 제약을 없애고 더 많은 프로세스를 실행시킬 수 있는 것입니다.\n<img src=\"/assets/IMG_D3F891F9DE9F-1.jpeg\" alt=\"IMG_D3F891F9DE9F-1\"></p>\n<p>Swapping의 개념과 거의 비슷하다고 보시면 됩니다. 그 단위가 Page라고 생각하면 됩니다.</p>\n<h4 id=\"active한-page를-판별하는-방법\" style=\"position:relative;\"><a href=\"#active%ED%95%9C-page%EB%A5%BC-%ED%8C%90%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"active한 page를 판별하는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Active한 Page를 판별하는 방법</h4>\n<p>Swap Out &#x26; In이 Active한 Page를 구별해서 일어난다는 것은 알았는데, 어떻게 아는걸까요?\nDemand Paging의 Trigger 역할을 하는 메커니즘은 <code class=\"language-text\">Page Fault</code>입니다.</p>\n<p>Page Table은 Logical Memory(Page)와 Physical Memory(Frame)의 매핑 정보를 담은 Table인데, 여기에 <code class=\"language-text\">valid - invalid Bit</code>을 추가합니다.(1bit)\n<img src=\"/assets/IMG_FDED4DEDC169-1.jpeg\" alt=\"IMG_FDED4DEDC169-1\"></p>\n<p>초기에는 모두 Invalid로 설정되어있고, 이 비트가 Page 주소를 참조하려 할때 Invalid면 Page Fault가 발생하여 Swap In 후 Valid한 것으로 바꿔줍니다.</p>\n<p>쉽게 말하자면 스케줄러가 Page 주소를 참조하려 한다는 것은 <code class=\"language-text\">Active</code>하다는 것입니다. 필요하다는(Demand) 것이죠. 그래서 Page Table을 살펴봤더니 아직 메모리에 적재가 안된것입니다. (Invalid) 그래서 Page Fault가 발생하고, Backing Store에서 페이지를 가져와 실제 메모리에 적재를 마치고 Valid로 바꿔줍니다.</p>\n<p>이렇게 되면 Logical Memory(Page)와 Physical Memory(Frame)의 매핑정보를 담은 Page Table에, 실제로 메모리에 적재되었는지 여부까지 알 수 있게 되는 것이죠.</p>\n<h4 id=\"page-replacement-frame이-다-배정되었을-때\" style=\"position:relative;\"><a href=\"#page-replacement-frame%EC%9D%B4-%EB%8B%A4-%EB%B0%B0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C\" aria-label=\"page replacement frame이 다 배정되었을 때 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Page Replacement (Frame이 다 배정되었을 때)</h4>\n<p>이렇게 Swap In을 통해 물리 메모리에 모든 Page를 적재해서 공간이 없어졌는데 Page가 필요하게 되면 어떡할까요?</p>\n<p><code class=\"language-text\">Victim Frame</code>, 즉 희생할 이미 배정되어 있는 Frame을 선택해서 Swap Out하고 필요한 Page를 Swap In해야겠죠? 이 과정이 <code class=\"language-text\">Page Replacement</code>입니다.</p>\n<p><img src=\"/assets/IMG_FDED4DEDC169-1_oq2d50n87.jpeg\" alt=\"IMG_FDED4DEDC169-1\"></p>\n<p>정리하자면, Page Replacement의 과정은 다음과 같습니다.</p>\n<ol>\n<li>디스크에서 필요한 Page를 찾는다.</li>\n<li>Victim Frame을 선정하고 Swap out</li>\n<li>필요한 Page를 Swap In</li>\n</ol>\n<p>중요한 부분은 <code class=\"language-text\">Victim Frame</code>을 어떻게 선정해야 할것인가? 입니다. 알고리즘이 굉장히 중요하고 성능에 영향을 미칩니다. 오랫동안 사용되지 않은 Frame을 잘 선정하는 것이 중요하죠.</p>\n<p>본 포스팅에서는 자세히 설명하진 않지만 알고리즘에는 다음의 알고리즘들이 존재합니다.</p>\n<ul>\n<li>FIFO\n가장 먼저 들어온 Frame을 Victim 으로 선정</li>\n<li>Optimal Algorithm\n가장 이후에 참조될 Frame을 Victim 으로 선정</li>\n<li>LRU(Least Recently Used Algorithm)\n가장 오래전에 참조된 것을 Frame을 Victim 으로 선정</li>\n<li>Counting Algorithm\n시간이 아닌 <code class=\"language-text\">빈도</code>를 기준으로 Victim Frame 선정\n<ul>\n<li>LFU(Least Frequently Used)</li>\n<li>MFU(Most Frequently Used)</li>\n</ul>\n</li>\n</ul>\n<p>성능이 가장 좋은 것은 <code class=\"language-text\">Optimal Algorithm</code> 이지만, 미래에 어떤 Frame이 설정될 지는 알 수 없어서 구현이 어렵습니다. 그래서 성능을 비교하기 위해 사용합니다. <code class=\"language-text\">FIFO</code> 알고리즘은 성능이 안좋고, <code class=\"language-text\">LRU</code> 알고리즘은 가장 성능이 좋습니다. Counting Algorithm은 흔하지 않습니다.</p>\n<p><code class=\"language-text\">LRU</code> 알고리즘의 실제 구현 또한 어려우나 하드웨어를 추가적으로 사용하여 비슷한 알고리즘을 구현할 수 있습니다. (언제 참조됐는지를 기록할 Register)</p>\n<ul>\n<li>Reference Bit</li>\n<li>Additional Reference Bits</li>\n<li>Second Chance</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC\">메모리 관리 기법과 가상 메모리</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95%EC%9D%98-%EB%91%90%EA%B0%80%EC%A7%80-%EB%AA%A9%EC%A0%81\">메모리 관리 기법의 두가지 목적</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%B2%95\">메모리 관리 기법</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\">연속적 Address Binding</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81-address-binding\">비연속적 Address Binding</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EC%97%B0%EC%86%8D%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC-%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94-%EB%91%90%EA%B0%80%EC%A7%80-%EA%B8%B0%EB%B2%95\">비연속적으로 메모리를 할당하는 두가지 기법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#demand-paging\">Demand Paging</a></p>\n<ul>\n<li>\n<p><a href=\"#swapping\">Swapping</a></p>\n<ul>\n<li><a href=\"#demand-paging%EA%B3%BC-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC\">Demand Paging과 가상메모리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#active%ED%95%9C-page%EB%A5%BC-%ED%8C%90%EB%B3%84%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">Active한 Page를 판별하는 방법</a></p>\n</li>\n<li>\n<p><a href=\"#page-replacement-frame%EC%9D%B4-%EB%8B%A4-%EB%B0%B0%EC%A0%95%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C\">Page Replacement (Frame이 다 배정되었을 때)</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 03, 2021","title":"메모리 관리 기법과 가상 메모리","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/memory-management/"}},"prev":{"id":"e8468b17-0f1f-58a1-9e97-932dcea7d541","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB67laESv/xAAWEAADAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFX//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8BNX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARAhETGx/9oACAEBAAE/IQaq+Roy3H//2gAMAwEAAgADAAAAEO/v/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QChn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAhMRD/2gAIAQEAAT8QJBMw+PeSPgqp6Z5Fplbv/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg\"\n        srcset=\"/static/051302852db76565424e416e3d55fbc9/4ec73/database_sql_vs_nosql.jpg 180w,\n/static/051302852db76565424e416e3d55fbc9/158ba/database_sql_vs_nosql.jpg 360w,\n/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg 720w,\n/static/051302852db76565424e416e3d55fbc9/acb04/database_sql_vs_nosql.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[Database] SQL과 NoSQL의 비교</p>\n<h2 id=\"sql\" style=\"position:relative;\"><a href=\"#sql\" aria-label=\"sql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h2>\n<p>SQL이란 Structured Query Language 입니다. RDBMS(관계형 데이터베이스 관리 시스템)과 상호 작용을 하기 위한 언어이며, 데이터베이스가 아닙니다. 어쨌든 중요한건 SQL는 관계형 데이터베이스를 다룰 때 사용한다는 것입니다.</p>\n<p><strong>RDBMS에는 두가지의 중요한 특성이 있습니다.</strong></p>\n<ul>\n<li>데이터는 정해진(엄격한) 데이터 스키마 (= structure)를 따라 데이터베이스 테이블에 저장됩니다.</li>\n<li>데이터는 관계를 통해서 연결된 여러개의 테이블에 분산됩니다.</li>\n</ul>\n<h3 id=\"엄격한-스키마\" style=\"position:relative;\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\" aria-label=\"엄격한 스키마 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엄격한 스키마</h3>\n<p>데이터는 Table에 Record로 저장이 되며, 명확하게 정의된 Schema가 존재합니다. Schema는 구조이며, 이 구조에 적합하지 않은 Record는 Table에 추가할 수가 없습니다. 그래서 <code class=\"language-text\">엄격한</code> 이란 표현을 쓰는겁니다.</p>\n<h3 id=\"관계\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EA%B3%84\" aria-label=\"관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계</h3>\n<p>이름에서부터 알 수 있듯이 <code class=\"language-text\">관계형 데이터베이스</code> 입니다. 각 테이블마다 관계를 맺고있다는 뜻입니다. 이게 중요한 이유는 중복을 피할 수 있다는 것입니다. 그 관계는 Foregin Key와 Primary Key로 구현을 합니다. 예를들어서 어떤 유저가 어떤 주문을 했는지를 조회하고자 해봅시다. 만약 테이블마다 관계를 맺을 수 없다면 유저 테이블에 어떤 주문을 했는지를 표시해야 할 것이고, 주문 테이블에 유저의 정보를 모두 넣어줘야겠습니다.</p>\n<p>하지만 명확하게 한개로만 구분되는 Primary Key(id..etc)를 Foregin Key로 가져와 관계를 맺을 수 있다면, 서로 테이블간 레코드가 중복될 필요 없이 데이터를 조회할 수 있습니다. <code class=\"language-text\">Join</code> 연산을 사용해서요.</p>\n<hr>\n<h2 id=\"nosql\" style=\"position:relative;\"><a href=\"#nosql\" aria-label=\"nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h2>\n<p>NoSQL은 이름처럼 SQL과 반대의 방식으로 데이터베이스에 접근하기 때문에 지어졌습니다.</p>\n<p>SQL의 주요한 특성인</p>\n<ul>\n<li>스키마</li>\n<li>관계</li>\n</ul>\n<p>이 두 개가 없습니다.</p>\n<p>이 두 개가 없다는 말은 곧, 스키마(구조)를 따르지 않고 데이터를 <code class=\"language-text\">Collection(RDBMS의 테이블)</code> 에 추가할 수 있습니다.</p>\n<p>관계가 없기 때문에 <code class=\"language-text\">Join</code> 의 개념또한 없습니다. 위에서 설명했던 유저와 주문의 관계를 살펴본다면, 주문이라는 컬렉션의 모든 유저의 정보를 같이 저장하는 겁니다.</p>\n<p>위 방식은 데이터가 중복되기 때문에, 중복되는 데이터를 수정하는 경우 모두 다 업데이트 되도록 하는 것이 중요하다고 할 수 있습니다. 그래서 자주 변경되지 않는 데이터 일 때 큰 장점이 있습니다.</p>\n<hr>\n<h2 id=\"두-데이터베이스의-비교\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"두 데이터베이스의 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 데이터베이스의 비교</h2>\n<h3 id=\"수직적-vs-수평적-확장scailing\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\" aria-label=\"수직적 vs 수평적 확장scailing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수직적 vs 수평적 확장(Scailing)</h3>\n<p>데이터베이스의 확장성이 어느 방향에 있냐에 따라서 두 데이터베이스가 나뉘게 됩니다.</p>\n<ul>\n<li><strong>수직적 확장</strong>은 데이터베이스 서버의 성능을 향상시키는 겁니다. (CPU 등의 하드웨어 교체)</li>\n<li><strong>수평적 확장</strong>은 서버를 분산시키는 것을 의미합니다.</li>\n</ul>\n<p><code class=\"language-text\">RDBMS</code> 에서는 수직적 확장만 가능합니다. 수평적 확장(Sharding)을 할 수는 있지만 구현하는게 굉장히 까다롭습니다. <code class=\"language-text\">NoSQL</code>에서는 이를 기본적으로 지원하므로 서버를 더 많이 추가하여 분산시키는 것이 가능합니다.</p>\n<h2 id=\"각-데이터베이스의-장단점\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"각 데이터베이스의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 데이터베이스의 장단점</h2>\n<p>둘 중 뭐가 낫다는 없습니다. 구현해야할 상황에 따라서 어떠한 데이터를 다루는지, 어플리케이션이 어떠한 특징을 가지고 있는지에 따라서 유연하게 선택해야합니다.</p>\n<h3 id=\"sql의-장단점\" style=\"position:relative;\"><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"sql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마를 명확히 정의하여 무결성 보장</li>\n<li>Record의 중복이 없음</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li><code class=\"language-text\">NoSQL</code>에 비해서 상대적으로 덜 유연하기 때문에 나중에 수정이 번거롭다. 불가능할 수도 있다.</li>\n<li>Join문이 많은 복잡한 쿼리가 만들어 질 수 있다.</li>\n<li>수평적 확장이 어렵고 대체로 수직적 확장만 가능하다. 이렇게 되면 어느 시점에서 한계점에 직면할 수 있다.</li>\n</ul>\n<h3 id=\"nosql의-장단점\" style=\"position:relative;\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"nosql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마가 없어 굉장히 유연하다. 언제든지 구조에 신경쓰지 않고 새로운 <code class=\"language-text\">Document</code> 를 추가할 수 있다.</li>\n<li>데이터는 어플리케이션에서 요구하는 형식으로 저장되기 때문에 데이터를 읽어오는 속도가 빨라진다.</li>\n<li>수직적, 수평적 확장이 모두 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>유연함 때문에 오히려 데이터의 구조가 제대로 안정해질 수도 있다.</li>\n<li>중복된 데이터가 변경되면 중복된 데이터가 있는 여러개의 <code class=\"language-text\">Collection</code>에서 변경이 이뤄져야 한다.</li>\n</ul>\n<h2 id=\"각각은-언제-사용하는-것이-좋을까\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"각각은 언제 사용하는 것이 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각각은 언제 사용하는 것이 좋을까?</h2>\n<h3 id=\"sql-1\" style=\"position:relative;\"><a href=\"#sql-1\" aria-label=\"sql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h3>\n<ul>\n<li>데이터가 자주 변경되어야 하는 경우(NoSQL은 컬렉션을 모두 수정해야 하기 때문에)</li>\n<li>구조가 변경될 여지가 없으며 명확한 스키마를 정의하는 것이 사용자와 데이터에게 중요한 경우</li>\n</ul>\n<h3 id=\"nosql-1\" style=\"position:relative;\"><a href=\"#nosql-1\" aria-label=\"nosql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h3>\n<ul>\n<li>정확한 데이터 구조를 몰라 변경, 확장이 될 수 있는 경우</li>\n<li>조회는 많이 하지만 데이터의 변경이 자주 있지 않는 경우</li>\n<li>데이터베이스를 수평적으로 확장해야 하는 경우, 즉 굉장히 많은 양의 데이터를 다뤄야 하는 경우</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#sql\">SQL</a></p>\n<ul>\n<li><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\">엄격한 스키마</a></li>\n<li><a href=\"#%EA%B4%80%EA%B3%84\">관계</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nosql\">NoSQL</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\">두 데이터베이스의 비교</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\">수직적 vs 수평적 확장(Scailing)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">각 데이터베이스의 장단점</a></p>\n<ul>\n<li><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">SQL의 장단점</a></li>\n<li><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">NoSQL의 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">각각은 언제 사용하는 것이 좋을까?</a></p>\n<ul>\n<li><a href=\"#sql-1\">SQL</a></li>\n<li><a href=\"#nosql-1\">NoSQL</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2021","title":"SQL과 NoSQL의 비교","categories":"Database","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/SQL-VS-NOSQL/"}},"site":{"siteMetadata":{"siteUrl":"https://codesik.github.io","comments":{"utterances":{"repo":"CodeSik/CodeSik.github.io"}}}}},"pageContext":{"slug":"/java-gc/","nextSlug":"/memory-management/","prevSlug":"/SQL-VS-NOSQL/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}