{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/Asymmetric-Key/",
    "result": {"data":{"cur":{"id":"6bccb300-15bc-558e-8bec-3cff9e5432a3","html":"<p class=\"callout\"> 💡[Security] 비대칭 암호화와 RSA 알고리즘 </p>\n## 비대칭 암호화\n<p>비대칭 암호화는 암호화, 복호화에 사용하는 키가 2개인 암호화 방식을 의미합니다.</p>\n<p>그 키는 Public Key, Private Key로 나뉩니다.</p>\n<p>일반적으로 Public Key는 자물쇠, Private Key는 그 자물쇠에 맞는 열쇠라고 생각하면 편합니다.</p>\n<p>다만 Public Key, Private Key 둘 다 서로 암호화, 복호화에 사용할 순 있습니다. 일반적으로 그렇다는 겁니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 710px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABNElEQVQY012P30rDMBTG81h7D30h9QnEK/HGR5jgvBwyBJmgAVeos1tpteu6LWvaJm36J8mRpjhXfxfJ+c75voSDwKDNuWGVtxfQpxulQi5IobQ+HqHu6rqTD3L75LdS6X/hRDRWyPtZQPoXAFhs2HydtQEjD30AKGq53OV/L5o+OhZFnouiMLJnAgCpFKVJfx+NOOd5nneeaBcH0f7wJ2OsqqrOWTdy7n53ddM0aZpKKdF2u8UYM8YAAHsU+7SWqqxagiCYzWZSSgAgrHxZ7mNeaSWTJHUcx7Zt9DlvcdyvmGYnl8+Ds8f35WYVkbwQlmXdj+7DaEfj5GbsDC4md1OPkMT1Q4zffN9HxCDKErS+HrvnQ5vyUgihlArDcPQwis2qw9fV6dUUe1TLOmM8itZZlv0AKWHCK8sGp2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/95c292059a5f62745cd430735f538270/7131f/1.png\"\n        srcset=\"/static/95c292059a5f62745cd430735f538270/e9ff0/1.png 180w,\n/static/95c292059a5f62745cd430735f538270/f21e7/1.png 360w,\n/static/95c292059a5f62745cd430735f538270/7131f/1.png 710w\"\n        sizes=\"(max-width: 710px) 100vw, 710px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>출처: codedragon.tistory.com</p>\n</blockquote>\n<h3 id=\"방식\" style=\"position:relative;\"><a href=\"#%EB%B0%A9%EC%8B%9D\" aria-label=\"방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>방식</h3>\n<p>만약에 A 서버와 B 클라이언트가 정보를 교환한다고 해봅시다.</p>\n<p>A는 B에게 공개키를 제공합니다. 그리고 B가 정보를 보낼 때 공개키로 암호화를 해서 보냅니다.</p>\n<p>이렇게 되면 B가 보낸 정보는 A의 개인키로 밖에 열지 못하기 때문에 유출되더라도 위험하지 않으며</p>\n<p>A에게만 비공개적으로 정보를 보낼 수 있는 것입니다.</p>\n<h3 id=\"https\" style=\"position:relative;\"><a href=\"#https\" aria-label=\"https permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTPS</h3>\n<p>HTTPS 프로토콜 상에서 통신하는 A 서버와 B 클라이언트가 서로 정보를 교환해야 한다고 가정해봅시다.</p>\n<blockquote>\n<p>HTTPS란?<br></p>\n</blockquote>\n<p>SSL 프로토콜위에서 동작하는 HTTP. 서버가 SSL 인증서를 CA 기관에서 발급받아 정보를 안전하게 교환할 수 있도록 보안성을 높인 프로토콜이다.</p>\n<p>먼저 서버는 CA기관으로 부터 SSL 인증서를 발급받습니다.</p>\n<p>CA에게 공개키를 제공하고, CA는 A의 공개키를 인증기관의 개인키로 암호화합니다.</p>\n<p>그리고 CA에서 발행한 공개키를 통해 이 것을 복호화 하면 인증서에 대한 해쉬값을 얻을 수 있습니다.</p>\n<p>인증서에 등록된 해쉬값과 CA에서 발행한 공개키로 서명값을 복호화해서 나온 것이 서로 동일하면 인증서의 내용과 공개키가 위,변조 되지 않았음을 보증할 수 있습니다.</p>\n<p>클라이언트의 브라우저로 서버에 접속하게 되면, 서버에서 인증서를 사용자에게 제공합니다.</p>\n<p>브라우저가 인증서를 발급한 기관이 브라우저에 등록된 인증기관 리스트에 있는지 확인하고, 인증기관의 공개키를 통해 제공받은 인증서를 복호화합니다. 복호화가 성공하게 되면 인증이 완료되는 것이죠.</p>\n<h3 id=\"블록체인\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\" aria-label=\"블록체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>블록체인</h3>\n<p>블록체인에서 자신의 Transaction에 Sign을 할 때도 같은 방식이 사용됩니다.</p>\n<p>트랜잭션을 발생시킨 공개키가 자신의 트랜잭션이다 라는 것을 자신의 개인키로 서명해야만 트랜잭션이 전송되어 블록체인 네트워크에 기록되는 것입니다.</p>\n<p>블록체인에서의 협의 방식은 HTTPS 처럼 인증 가능한 기관이 있는 것이 아닌 <code class=\"language-text\">Proof of Work(POW)</code> 매커니즘을 통해 이뤄집니다.</p>\n<p>간단히 설명하자면 그렇게 서명하여 보낸 트랜잭션이 Valid한지 블록체인 네트워크에 등록된 노드들이 검사를 하는 매커니즘입니다.</p>\n<h3 id=\"rsa-알고리즘\" style=\"position:relative;\"><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"rsa 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RSA 알고리즘</h3>\n<p>비대칭 암호화를 구현하기 위한 대표적인 알고리즘은 RSA알고리즘 입니다. 공개키와 개인키를 생성하기 위한 알고리즘 입니다.</p>\n<p>공개키는 n,e / 개인키는 n,d 라는 각각 두 정수로 이뤄져 있습니다.</p>\n<p>구하는 알고리즘은 다음과 같습니다.</p>\n<ul>\n<li>\n<p>p ≠ q인 두 소수 p와 q를 고릅니다. (EX: p = 17, q = 11)</p>\n</li>\n<li>\n<p>N=pq인 N을 만듭니다. (N = 187)</p>\n</li>\n<li>\n<p>Φ(N)=(p-1)(q-1)을 계산합니다. (16*10 = 160)</p>\n</li>\n<li>\n<p>공개키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 서로소인 수 e를 선택합니다. (e=7)</p>\n</li>\n<li>\n<p>개인키를 구합니다.</p>\n<p>Φ(N) = 160 보다 작으면서 d*e mod 160 = 1인 수 를 구합니다. e가 7이었으므로</p>\n<p>7d mod 160 =1을 만족하는 d는 (160+1)/7 이므로, 23입니다.</p>\n</li>\n</ul>\n<p>따라서 결과적으로 공개키는 (187,7) / 개인키는 (187,23)이 됩니다.</p>\n<h3 id=\"암호화-공개키의-n과-e\" style=\"position:relative;\"><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\" aria-label=\"암호화 공개키의 n과 e permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>암호화 (공개키의 n과 e)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C = M^e mod n</code></pre></div>\n<h3 id=\"복호화-개인키의-n과-d\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\" aria-label=\"복호화 개인키의 n과 d permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복호화 (개인키의 n과 d)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">M = C^d mod n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%B0%A9%EC%8B%9D\">방식</a></li>\n<li><a href=\"#https\">HTTPS</a></li>\n<li><a href=\"#%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8\">블록체인</a></li>\n<li><a href=\"#rsa-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">RSA 알고리즘</a></li>\n<li><a href=\"#%EC%95%94%ED%98%B8%ED%99%94-%EA%B3%B5%EA%B0%9C%ED%82%A4%EC%9D%98-n%EA%B3%BC-e\">암호화 (공개키의 n과 e)</a></li>\n<li><a href=\"#%EB%B3%B5%ED%98%B8%ED%99%94-%EA%B0%9C%EC%9D%B8%ED%82%A4%EC%9D%98-n%EA%B3%BC-d\">복호화 (개인키의 n과 d)</a></li>\n</ul>\n</div>","excerpt":"비대칭 암호화는 암호화, 복호화에 사용하는 키가 2개인 암호화 방식을 의미합니다. 그 키는 Public Key, Private Key로 나뉩니다. 일반적으로 Public Key는 자물쇠, Private Key는 그 자물쇠에 맞는 열쇠라고 생각하면 편합니다. 다만 Public Key, Private Key 둘 다 서로 암호화, 복호화에 사용할 순 있습니다. 일반적으로 그렇다는 겁니다.  출처: codedragon.tistory.com 방식 만약에 A 서버와 B 클라이언트가 정보를 교환한다고 해봅시다. A는 B에게 공개키를 제공합니다. 그리고 B가 정보를 보낼 때 공개키로 암호화를 해서 보냅니다. 이렇게 되면 B가 보낸 정보는 A의 개인키로 밖에 열지 못하기 때문에 유출되더라도 위험하지 않으며 A에게만 비공개적으로 정보를 보낼 수 있는 것입니다. HTTPS HTTPS 프로토콜 상에서 통신하는 A 서버와 B 클라이언트가 서로 정보를 교환해야 한다고 가정해봅시다. HTTPS란? SSL 프…","frontmatter":{"date":"April 05, 2021","title":"비대칭 암호화와 RSA 알고리즘","categories":"CS","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/Asymmetric-Key/"}},"next":{"id":"e8468b17-0f1f-58a1-9e97-932dcea7d541","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQACBf/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB67laESv/xAAWEAADAAAAAAAAAAAAAAAAAAABIDH/2gAIAQEAAQUCFX//xAAWEQADAAAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8BNX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAAAARAhETGx/9oACAEBAAE/IQaq+Roy3H//2gAMAwEAAgADAAAAEO/v/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QChn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAhMRD/2gAIAQEAAT8QJBMw+PeSPgqp6Z5Fplbv/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"썸네일\"\n        src=\"/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg\"\n        srcset=\"/static/051302852db76565424e416e3d55fbc9/4ec73/database_sql_vs_nosql.jpg 180w,\n/static/051302852db76565424e416e3d55fbc9/158ba/database_sql_vs_nosql.jpg 360w,\n/static/051302852db76565424e416e3d55fbc9/80e3c/database_sql_vs_nosql.jpg 720w,\n/static/051302852db76565424e416e3d55fbc9/acb04/database_sql_vs_nosql.jpg 750w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p class=\"callout\"> 💡[Database] SQL과 NoSQL의 비교</p>\n<h2 id=\"sql\" style=\"position:relative;\"><a href=\"#sql\" aria-label=\"sql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h2>\n<p>SQL이란 Structured Query Language 입니다. RDBMS(관계형 데이터베이스 관리 시스템)과 상호 작용을 하기 위한 언어이며, 데이터베이스가 아닙니다. 어쨌든 중요한건 SQL는 관계형 데이터베이스를 다룰 때 사용한다는 것입니다.</p>\n<p><strong>RDBMS에는 두가지의 중요한 특성이 있습니다.</strong></p>\n<ul>\n<li>데이터는 정해진(엄격한) 데이터 스키마 (= structure)를 따라 데이터베이스 테이블에 저장됩니다.</li>\n<li>데이터는 관계를 통해서 연결된 여러개의 테이블에 분산됩니다.</li>\n</ul>\n<h3 id=\"엄격한-스키마\" style=\"position:relative;\"><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\" aria-label=\"엄격한 스키마 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>엄격한 스키마</h3>\n<p>데이터는 Table에 Record로 저장이 되며, 명확하게 정의된 Schema가 존재합니다. Schema는 구조이며, 이 구조에 적합하지 않은 Record는 Table에 추가할 수가 없습니다. 그래서 <code class=\"language-text\">엄격한</code> 이란 표현을 쓰는겁니다.</p>\n<h3 id=\"관계\" style=\"position:relative;\"><a href=\"#%EA%B4%80%EA%B3%84\" aria-label=\"관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>관계</h3>\n<p>이름에서부터 알 수 있듯이 <code class=\"language-text\">관계형 데이터베이스</code> 입니다. 각 테이블마다 관계를 맺고있다는 뜻입니다. 이게 중요한 이유는 중복을 피할 수 있다는 것입니다. 그 관계는 Foregin Key와 Primary Key로 구현을 합니다. 예를들어서 어떤 유저가 어떤 주문을 했는지를 조회하고자 해봅시다. 만약 테이블마다 관계를 맺을 수 없다면 유저 테이블에 어떤 주문을 했는지를 표시해야 할 것이고, 주문 테이블에 유저의 정보를 모두 넣어줘야겠습니다.</p>\n<p>하지만 명확하게 한개로만 구분되는 Primary Key(id..etc)를 Foregin Key로 가져와 관계를 맺을 수 있다면, 서로 테이블간 레코드가 중복될 필요 없이 데이터를 조회할 수 있습니다. <code class=\"language-text\">Join</code> 연산을 사용해서요.</p>\n<hr>\n<h2 id=\"nosql\" style=\"position:relative;\"><a href=\"#nosql\" aria-label=\"nosql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h2>\n<p>NoSQL은 이름처럼 SQL과 반대의 방식으로 데이터베이스에 접근하기 때문에 지어졌습니다.</p>\n<p>SQL의 주요한 특성인</p>\n<ul>\n<li>스키마</li>\n<li>관계</li>\n</ul>\n<p>이 두 개가 없습니다.</p>\n<p>이 두 개가 없다는 말은 곧, 스키마(구조)를 따르지 않고 데이터를 <code class=\"language-text\">Collection(RDBMS의 테이블)</code> 에 추가할 수 있습니다.</p>\n<p>관계가 없기 때문에 <code class=\"language-text\">Join</code> 의 개념또한 없습니다. 위에서 설명했던 유저와 주문의 관계를 살펴본다면, 주문이라는 컬렉션의 모든 유저의 정보를 같이 저장하는 겁니다.</p>\n<p>위 방식은 데이터가 중복되기 때문에, 중복되는 데이터를 수정하는 경우 모두 다 업데이트 되도록 하는 것이 중요하다고 할 수 있습니다. 그래서 자주 변경되지 않는 데이터 일 때 큰 장점이 있습니다.</p>\n<hr>\n<h2 id=\"두-데이터베이스의-비교\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"두 데이터베이스의 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 데이터베이스의 비교</h2>\n<h3 id=\"수직적-vs-수평적-확장scailing\" style=\"position:relative;\"><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\" aria-label=\"수직적 vs 수평적 확장scailing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수직적 vs 수평적 확장(Scailing)</h3>\n<p>데이터베이스의 확장성이 어느 방향에 있냐에 따라서 두 데이터베이스가 나뉘게 됩니다.</p>\n<ul>\n<li><strong>수직적 확장</strong>은 데이터베이스 서버의 성능을 향상시키는 겁니다. (CPU 등의 하드웨어 교체)</li>\n<li><strong>수평적 확장</strong>은 서버를 분산시키는 것을 의미합니다.</li>\n</ul>\n<p><code class=\"language-text\">RDBMS</code> 에서는 수직적 확장만 가능합니다. 수평적 확장(Sharding)을 할 수는 있지만 구현하는게 굉장히 까다롭습니다. <code class=\"language-text\">NoSQL</code>에서는 이를 기본적으로 지원하므로 서버를 더 많이 추가하여 분산시키는 것이 가능합니다.</p>\n<h2 id=\"각-데이터베이스의-장단점\" style=\"position:relative;\"><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"각 데이터베이스의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각 데이터베이스의 장단점</h2>\n<p>둘 중 뭐가 낫다는 없습니다. 구현해야할 상황에 따라서 어떠한 데이터를 다루는지, 어플리케이션이 어떠한 특징을 가지고 있는지에 따라서 유연하게 선택해야합니다.</p>\n<h3 id=\"sql의-장단점\" style=\"position:relative;\"><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"sql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마를 명확히 정의하여 무결성 보장</li>\n<li>Record의 중복이 없음</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li><code class=\"language-text\">NoSQL</code>에 비해서 상대적으로 덜 유연하기 때문에 나중에 수정이 번거롭다. 불가능할 수도 있다.</li>\n<li>Join문이 많은 복잡한 쿼리가 만들어 질 수 있다.</li>\n<li>수평적 확장이 어렵고 대체로 수직적 확장만 가능하다. 이렇게 되면 어느 시점에서 한계점에 직면할 수 있다.</li>\n</ul>\n<h3 id=\"nosql의-장단점\" style=\"position:relative;\"><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"nosql의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL의 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>스키마가 없어 굉장히 유연하다. 언제든지 구조에 신경쓰지 않고 새로운 <code class=\"language-text\">Document</code> 를 추가할 수 있다.</li>\n<li>데이터는 어플리케이션에서 요구하는 형식으로 저장되기 때문에 데이터를 읽어오는 속도가 빨라진다.</li>\n<li>수직적, 수평적 확장이 모두 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>유연함 때문에 오히려 데이터의 구조가 제대로 안정해질 수도 있다.</li>\n<li>중복된 데이터가 변경되면 중복된 데이터가 있는 여러개의 <code class=\"language-text\">Collection</code>에서 변경이 이뤄져야 한다.</li>\n</ul>\n<h2 id=\"각각은-언제-사용하는-것이-좋을까\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"각각은 언제 사용하는 것이 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각각은 언제 사용하는 것이 좋을까?</h2>\n<h3 id=\"sql-1\" style=\"position:relative;\"><a href=\"#sql-1\" aria-label=\"sql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SQL</h3>\n<ul>\n<li>데이터가 자주 변경되어야 하는 경우(NoSQL은 컬렉션을 모두 수정해야 하기 때문에)</li>\n<li>구조가 변경될 여지가 없으며 명확한 스키마를 정의하는 것이 사용자와 데이터에게 중요한 경우</li>\n</ul>\n<h3 id=\"nosql-1\" style=\"position:relative;\"><a href=\"#nosql-1\" aria-label=\"nosql 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>NoSQL</h3>\n<ul>\n<li>정확한 데이터 구조를 몰라 변경, 확장이 될 수 있는 경우</li>\n<li>조회는 많이 하지만 데이터의 변경이 자주 있지 않는 경우</li>\n<li>데이터베이스를 수평적으로 확장해야 하는 경우, 즉 굉장히 많은 양의 데이터를 다뤄야 하는 경우</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#sql\">SQL</a></p>\n<ul>\n<li><a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88\">엄격한 스키마</a></li>\n<li><a href=\"#%EA%B4%80%EA%B3%84\">관계</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nosql\">NoSQL</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%91%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%B9%84%EA%B5%90\">두 데이터베이스의 비교</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%EC%A7%81%EC%A0%81-vs-%EC%88%98%ED%8F%89%EC%A0%81-%ED%99%95%EC%9E%A5scailing\">수직적 vs 수평적 확장(Scailing)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">각 데이터베이스의 장단점</a></p>\n<ul>\n<li><a href=\"#sql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">SQL의 장단점</a></li>\n<li><a href=\"#nosql%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">NoSQL의 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">각각은 언제 사용하는 것이 좋을까?</a></p>\n<ul>\n<li><a href=\"#sql-1\">SQL</a></li>\n<li><a href=\"#nosql-1\">NoSQL</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2021","title":"SQL과 NoSQL의 비교","categories":"Database","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/SQL-VS-NOSQL/"}},"prev":{"id":"6d03880b-159c-54a4-934b-ccb110137c58","html":"<p class=\"callout\"> 💡[프로그래머스] Level 1 완주하지 못한 선수 | Python</p>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/42576\">문제 링크 및 출처</a></p>\n<p><img src=\"https://i.imgur.com/AJpyecC.png\" alt=\"스크린샷 2021-04-09 오후 8.32.06\"></p>\n<h2 id=\"풀이과정\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\" aria-label=\"풀이과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이과정</h2>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span> completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    <span class=\"token keyword\">for</span> com <span class=\"token keyword\">in</span> completion<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> com <span class=\"token keyword\">in</span> participant<span class=\"token punctuation\">:</span>\n            participant<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># print(participant)</span>\n    <span class=\"token keyword\">return</span> participant<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>처음에는 이렇게 풀었습니다. 완주한 사람의 목록에 있는 사람을 참가자에서 하나씩 빼는겁니다.</p>\n<p>정확도는 모두 맞는데 해시를 쓰지 않으면 조회시간이 오래걸려 효율성 테스트에서 모두 문제가 생깁니다. 따라서 해시기반 자료형을 사용해야 하는데, Python 에서는 <code class=\"language-text\">Dictionary</code>를 사용하면 됩니다.</p>\n<p>저는 근데 위 아이디어를 좀 더 살렸는데요, 파이썬 내장함수중에 <code class=\"language-text\">zip</code>이라는 함수가 있습니다.</p>\n<p>두 리스트를 같은 인덱스 끼리 Tuple로 묶어준다고 생각하시면 됩니다.</p>\n<p>그럼 sort를 한 뒤에 같은 인덱스 묶인 Tuple간 원소를 비교했을 때 다르다면 그게 답이 될겁니다.</p>\n<p>만약 if문에 안걸리면 마지막 원소가 답이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#11:30</span>\n<span class=\"token keyword\">def</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span> completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>  \n    participant<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    completion<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> a<span class=\"token punctuation\">,</span>b <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>participant<span class=\"token punctuation\">,</span>completion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> a<span class=\"token operator\">!=</span>b<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> a\n\n    <span class=\"token keyword\">return</span> participant<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4%EA%B3%BC%EC%A0%95\">풀이과정</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 09, 2021","title":"프로그래머스 - Level 1 완주하지 못한 선수 | Python","categories":"Algorithm","author":"CodeSik","emoji":"🧢"},"fields":{"slug":"/algorithm-1/"}},"site":{"siteMetadata":{"siteUrl":"https://codesik.github.io","comments":{"utterances":{"repo":"CodeSik/CodeSik.github.io"}}}}},"pageContext":{"slug":"/Asymmetric-Key/","nextSlug":"/SQL-VS-NOSQL/","prevSlug":"/algorithm-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}